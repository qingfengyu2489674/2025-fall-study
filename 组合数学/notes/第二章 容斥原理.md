## **2.1 容斥原理**

#### **核心思想**

容斥原理的本质是一种**修正错误**的计数方法。当我们想计算多个集合的**并集**大小时，直接把各个集合的大小相加，会导致重叠部分被重复计算。容斥原理的思想就是：

1.  **容 (Inclusion)**：先**过度计算**，把所有可能的情况全部加起来。
2.  **斥 (Exclusion)**：减去那些被重复计算的部分。
3.  **再容 (Inclusion)**：在减去的过程中，可能有些部分被“过度减去”了，需要再把它们加回来。
4.  **再斥 (Exclusion)**：...如此往复，直到修正完成。

这个过程就像筛筛子一样，加加减减，最终得到精确的数量。

#### **从简单到复杂：公式的演进**

1.  **一个集合 (补集思想)**
    -   **公式**: `|Ā| = |S| - |A|`
    -   **解读**: “不具有性质A”的数量 = 总数 - “具有性质A”的数量。这是所有容斥问题的基础。

2.  **两个集合**
    -   **并集公式 (至少一个)**: `|A₁ ∪ A₂| = |A₁| + |A₂| - |A₁ ∩ A₂|`
        -   **组合意义**: 拥有性质1**或**性质2的元素个数 = (拥有性质1的个数) + (拥有性质2的个数) - (同时拥有性质1**和**性质2的个数)。减去的 `|A₁ ∩ A₂|` 就是为了修正 `A₁` 和 `A₂` 重叠部分被加了两次的错误。
    -   **交集的补集公式 (一个都没有)**: `|Ā₁ ∩ Ā₂| = |S| - (|A₁|+|A₂|) + |A₁ ∩ A₂|`
        -   **组合意义**: “既不具有性质1，也不具有性质2”的数量 = 总数 - (只算性质1) - (只算性质2) + (同时算性质1和2)。

#### **定理 2.1 (一般形式 - 全不公式)**

这是容斥原理最通用的形式，用于计算“**一个指定性质都没有**”的元素个数。

-   **公式**: `|Ā₁ ∩ Ā₂ ∩ ... ∩ Āₘ| = |S| - Σ|Aᵢ| + Σ|Aᵢ ∩ Aⱼ| - Σ|Aᵢ ∩ Aⱼ ∩ Aₖ| + ... + (-1)ᵐ |A₁ ∩ ... ∩ Aₘ|`
-   **解读**:
    -   `|S|`: 全集总数。
    -   `- Σ|Aᵢ|`: 减去**至少有一个**性质的所有情况（单项）。
    -   `+ Σ|Aᵢ ∩ Aⱼ|`: 加回被错误减掉两次的**至少有两个**性质的所有情况（两两交集）。
    -   `- Σ|Aᵢ ∩ Aⱼ ∩ Aₖ|`: 减去被错误加回的**至少有三个**性质的所有情况（三三交集）。
    -   ...符号 `+` 和 `-` 交替出现。

#### **推论 1 (一般形式 - 至少一个公式)**

这是定理2.1的孪生兄弟，用于计算“**至少具有一个**指定性质”的元素个数。

-   **公式**: `|A₁ ∪ A₂ ∪ ... ∪ Aₘ| = Σ|Aᵢ| - Σ|Aᵢ ∩ Aⱼ| + Σ|Aᵢ ∩ Aⱼ ∩ Aₖ| - ...`
-   **关系**: `|A₁ ∪ ... ∪ Aₘ| = |S| - |Ā₁ ∩ ... ∩ Āₘ|`。

---

### **例题深度解析**

#### **【例1】学生兴趣问题 (经典模型)**

-   **任务**: 求对三门课都**不喜爱**的学生数。
-   **建模**:
    -   `S`: 全班60名学生。
    -   `A₁`: 喜爱数学的集合。`|A₁|=24`。
    -   `A₂`: 喜爱物理的集合。`|A₂|=28`。
    -   `A₃`: 喜爱化学的集合。`|A₃|=26`。
    -   交集: `|A₁∩A₂|=10`, `|A₁∩A₃|=8`, `|A₂∩A₃|=14`, `|A₁∩A₂∩A₃|=6`。
-   **求解**: 目标是 `|Ā₁ ∩ Ā₂ ∩ Ā₃|`。直接套用“全不公式”。
    `= |S| - (|A₁|+|A₂|+|A₃|) + (|A₁∩A₂|+|A₁∩A₃|+|A₂∩A₃|) - |A₁∩A₂∩A₃|`
    `= 60 - (24+28+26) + (10+8+14) - 6 = 8`。

#### **【例2】整除问题**

-   **任务**: 1到1000中，**不能**被5、6、8中任何一个整除的数。
-   **建模**:
    -   `S`: `{1, 2, ..., 1000}`。 `|S|=1000`。
    -   `A₁`: 能被5整除的数的集合。`|A₁| = ⌊1000/5⌋ = 200`。
    -   `A₂`: 能被6整除的数的集合。`|A₂| = ⌊1000/6⌋ = 166`。
    -   `A₃`: 能被8整除的数的集合。`|A₃| = ⌊1000/8⌋ = 125`。
-   **关键点：交集的计算**
    -   一个数**同时**能被 `a` 和 `b` 整除，等价于它能被 `a` 和 `b` 的**最小公倍数 (LCM)** 整除。
    -   `|A₁ ∩ A₂|`: 能被5和6整除的数 = 能被 `LCM(5,6)=30` 整除的数。`⌊1000/30⌋=33`。
    -   `|A₁ ∩ A₃|`: 能被 `LCM(5,8)=40` 整除的数。`⌊1000/40⌋=25`。
    -   `|A₂ ∩ A₃|`: 能被 `LCM(6,8)=24` 整除的数。`⌊1000/24⌋=41`。
    -   `|A₁ ∩ A₂ ∩ A₃|`: 能被 `LCM(5,6,8)=120` 整除的数。`⌊1000/120⌋=8`。
-   **求解**: 目标 `|Ā₁ ∩ Ā₂ ∩ Ā₃|`。套用“全不公式”，将上述数值代入即可。
    `= 1000 - (200+166+125) + (33+25+41) - 8 = 600` (注：原文计算有误，应为600)

#### **【例3】欧拉函数 `φ(n)`**

-   **任务**: 求小于 `n` 且与 `n` **互素**的正整数个数。
-   **建模**:
    -   `S`: `{1, 2, ..., n}`。`|S|=n`。
    -   **互素的对立面**：与 `n` **不互素**。一个数与 `n` 不互素，意味着它与 `n` 有**共同的质因子**。
    -   设 `n` 的质因子分解为 `p₁ᵃ¹ * p₂ᵃ² * ...`。
    -   `Aᵢ`: `S` 中能被质因子 `pᵢ` 整除的数的集合。
-   **求解**: `φ(n)` 就是 `S` 中**不能**被任何一个 `pᵢ` 整除的数的个数，即 `|Ā₁ ∩ Ā₂ ∩ ...|`。
    -   `|Aᵢ| = n/pᵢ`。
    -   `|Aᵢ ∩ Aⱼ| = n/(pᵢpⱼ)`。
    -   ...
-   **代入公式**: `φ(n) = n - Σ(n/pᵢ) + Σ(n/(pᵢpⱼ)) - ...`
-   **因式分解**: `φ(n) = n * (1 - 1/p₁) * (1 - 1/p₂) * ...`。这是欧拉函数的积性公式，由容斥原理推导而来。

#### **【例4】在由 a,b,c,d 4个字符构成的n位符号串中,求a,b和c至少出现一次的符号串的数目。**

-   **任务**: `a,b,c` **至少出现一次**。
-   **建模 (逆向思维)**: “至少一个”通常比“一个都没有”更难算。我们转而求它的**反面**：`a,b,c` **不都**出现。
    -   `S`: 4个字符构成的n位符号串总数。`|S|=4ⁿ`。
    -   `A₁`: **不出现 a** 的符号串。只能用`b,c,d`，`|A₁|=3ⁿ`。
    -   `A₂`: **不出现 b** 的符号串。`|A₂|=3ⁿ`。
    -   `A₃`: **不出现 c** 的符号串。`|A₃|=3ⁿ`。
-   **目标**: 原始问题是求 `S - (A₁ ∪ A₂ ∪ A₃)` 的大小，即 `|Ā₁ ∩ Ā₂ ∩ Ā₃|`。
-   **计算交集**:
    -   `|A₁ ∩ A₂|`: 既不出现a也不出现b。只能用`c,d`，`|A₁∩A₂|=2ⁿ`。
    -   `|A₁ ∩ A₂ ∩ A₃|`: a,b,c都不出现。只能用`d`，`|A₁∩A₂∩A₃|=1ⁿ=1`。
-   **求解**: 套用“全不公式”：`|S| - 3*|Aᵢ| + 3*|Aᵢ∩Aⱼ| - |A₁∩A₂∩A₃| = 4ⁿ - 3*3ⁿ + 3*2ⁿ - 1`。

#### **【例5】求集合 A={a,b,c,d,e,f,g,h}的全排列中,abc 和efgh 均不出现的全排列 个数。**

-   **任务**: `abc` 和 `efgh` **均不出现**的全排列。
-   **建模**:
    -   `S`: 8个字母的全排列。`|S|=8!`。
    -   `A₁`: **出现 `abc`** 的排列。把 `abc` 捆绑成一个大字母，相当于6个元素的全排列。`|A₁|=6!`。
    -   `A₂`: **出现 `efgh`** 的排列。把 `efgh` 捆绑，相当于5个元素的全排列。`|A₂|=5!`。
    -   `|A₁ ∩ A₂|`: **同时出现 `abc` 和 `efgh`**。把 `abc` 和 `efgh` 都捆绑，相当于3个元素(`(abc), d, (efgh)`)的全排列。`|A₁∩A₂|=3!`。
-   **求解**: 目标 `|Ā₁ ∩ Ā₂|`。套用两个集合的“全不公式”：
    `= |S| - (|A₁|+|A₂|) + |A₁∩A₂| = 8! - (6!+5!) + 3!`。

#### **【例6】把n本不同的书放入m个有编号的箱子中(n≥m),使得没有一个箱子为空, 问共有多少种放法?**

-   **任务**: `n` 本**不同**的书，放入 `m` 个**不同**的箱子，**无一空盒**。
-   **建模 (逆向思维)**:
    -   `S`: `n` 本书放入 `m` 个箱子的**所有**放法。每本书有 `m` 种选择，`|S|=mⁿ`。
    -   **反面**: “**至少有一个**箱子为空”。
    -   `Aᵢ`: 第 `i` 个箱子为空的性质。
-   **计算**:
    -   `|Aᵢ|`: 第 `i` 箱为空，`n` 本书只能放入 `m-1` 个箱子。`|Aᵢ|=(m-1)ⁿ`。
    -   `|Aᵢ ∩ Aⱼ|`: 第 `i,j` 两个箱子为空，书只能放入 `m-2` 个箱子。`|Aᵢ∩Aⱼ|=(m-2)ⁿ`。
    -   ...
-   **组合数的作用**:
    -   `Σ|Aᵢ|` 有 `m` 个这样的项吗？不对，是从 `m` 个箱子中选 `1` 个为空，有 `C(m,1)` 种选法。所以 `Σ|Aᵢ| = C(m,1)*(m-1)ⁿ`。
    -   `Σ|Aᵢ∩Aⱼ| = C(m,2)*(m-2)ⁿ`。
    -   ...
-   **求解**: 目标是“无一空盒”，即 `|Ā₁ ∩ ... ∩ Āₘ|`。套用“全不公式”：
    `= |S| - C(m,1)(m-1)ⁿ + C(m,2)(m-2)ⁿ - ...`
    `= Σ [k=0 to m] (-1)ᵏ * C(m,k) * (m-k)ⁿ`。

---
### **本节总结**
容斥原理是处理复杂约束计数问题的利器，其核心是**正向问题难，逆向思维解**。

-   **基本步骤**:
    1.  确定**全集 `S`** 是什么，计算其大小 `|S|`。
    2.  明确要排除的**性质 `pᵢ`** 是什么（例如“箱子为空”、“能被整除”、“不出现某字符”）。
    3.  计算只满足**一个性质**的集合大小 `|Aᵢ|`，并计算这类情况的总和 `Σ|Aᵢ|`。
    4.  计算同时满足**两个性质**的集合大小 `|Aᵢ∩Aⱼ|`，并计算总和 `Σ|Aᵢ∩Aⱼ|`。
    5.  以此类推，计算所有多重交集的大小。
    6.  将这些值代入容斥原理的公式（“全不”或“至少一个”），符号**加减交替**。





## **2.2 重集的r-组合**

#### **核心问题回顾**

-   **第一章我们学了什么？**
    -   我们学会了计算“**无限供应**”的重复组合问题。
    -   问题模型：从 `n` 类物品中，可重复地选 `r` 个，每类物品数量无限。
    -   公式：`F(n, r) = C(n + r - 1, r)` (隔板法)。

-   **本节要解决什么新问题？**
    -   计算“**有限供应**”的重复组合问题。
    -   问题模型：从重集 `B={k₁·a₁, k₂·a₂, ...}` 中选 `r` 个。这意味着第 `i` 类物品 `aᵢ` 最多只能拿 `kᵢ` 个。

**例如**: `B={4·苹果, 3·香蕉}`，问拿5个水果 (`r=5`) 有多少种方法？
- `4苹果, 1香蕉` (√)
- `3苹果, 2香蕉` (√)
- `2苹果, 3香蕉` (√)
- `5苹果, 0香蕉` (× 不行！苹果最多只有4个)
- `1苹果, 4香蕉` (× 不行！香蕉最多只有3个)

直接计算非常困难，因为你需要考虑每个物品的数量上限，情况非常复杂。

---

### **容斥原理的解决思路 (逆向思维)**

解决这个问题的思路堪称绝妙，完美地体现了容斥原理的精髓：

1.  **第一步：无视所有限制 (构造全集 S)**
    -   我们先**假装**所有物品都是**无限供应**的。
    -   构造一个新的“理想重集” `B'={∞·a₁, ∞·a₂, ...}`。
    -   在这个理想情况下，从 `B'` 中取 `r` 个物品的总方案数，就是我们熟悉的不带限制的重复组合数。这个总方案数构成了我们的**全集 S**。
    -   `|S| = F(n, r) = C(n + r - 1, r)`。

2.  **第二步：定义“坏”的性质 (要被排除的情况)**
    -   我们的理想全集 `S` 中，包含了很多“不合法”的方案（即某些物品拿得太多了）。这些就是我们要用容斥原理排除掉的。
    -   什么是“坏”的方案？就是一个方案违反了至少一个数量上限。
    -   我们定义性质 `pᵢ` 为：“**在组合中，物品 `aᵢ` 的数量超过了其上限 `kᵢ`**”（即至少拿了 `kᵢ+1` 个）。
    -   `Aᵢ` 就是所有具有性质 `pᵢ` 的方案构成的集合。

3.  **第三步：求解目标**
    -   我们想要的合法方案，是那些**一个“坏”性质都没有**的方案。
    -   即，物品 `a₁` 的数量 `≤k₁` **并且** `a₂` 的数量 `≤k₂` **并且** ...
    -   这正是 `Ā₁ ∩ Ā₂ ∩ ... ∩ Āₙ`。
    -   我们可以直接套用容斥原理的“全不”公式来求解。

---

### **【例7】深度解析：`B={4·a₁, 3·a₂, 4·a₃, 5·a₄}` 的12-组合**

-   **任务**: `a₁`最多4个, `a₂`最多3个, `a₃`最多4个, `a₄`最多5个，总共拿12个。

#### **1. 计算全集 `|S|`**
-   **假设**：`a₁, a₂, a₃, a₄` 都是无限供应。
-   从4类物品中，可重复地选12个。
-   `|S| = F(4, 12) = C(4+12-1, 12) = C(15, 12) = C(15, 3) = 455`。

#### **2. 定义“坏”的性质 `pᵢ`**
-   `p₁`: `a₁` 的数量 `≥ 5` (超过了上限4)。
-   `p₂`: `a₂` 的数量 `≥ 4` (超过了上限3)。
-   `p₃`: `a₃` 的数量 `≥ 5` (超过了上限4)。
-   `p₄`: `a₄` 的数量 `≥ 6` (超过了上限5)。

#### **3. 计算 `|Aᵢ|` (至少违反一个限制)**
-   **`|A₁|` 的计算 (核心技巧)**:
    -   `A₁` 是所有“`a₁`至少拿5个”的12-组合的集合。
    -   **思想**: 我们先强制满足这个“坏”条件。从我们的12个名额中，**预先拿出5个名额分给 `a₁`**。
    -   现在我们手上还剩下 `12 - 5 = 7` 个名额需要分配。
    -   这7个名额可以**任意地**分配给 `a₁, a₂, a₃, a₄` 这4类物品（因为我们是在无限供应的理想世界 `B'` 中计算）。
    -   问题转化为：从4类物品中，可重复地选7个。
    -   `|A₁| = F(4, 7) = C(4+7-1, 7) = C(10, 7) = C(10, 3) = 120`。
-   **同理计算其他 `|Aᵢ|`**:
    -   `|A₂|`: 预先分4个给`a₂`，剩下8个名额。`F(4, 8) = C(11, 8) = 165`。
    -   `|A₃|`: 预先分5个给`a₃`，剩下7个名额。`F(4, 7) = 120`。
    -   `|A₄|`: 预先分6个给`a₄`，剩下6个名额。`F(4, 6) = C(9, 6) = 84`。

#### **4. 计算 `|Aᵢ ∩ Aⱼ|` (至少违反两个限制)**
-   **`|A₁ ∩ A₂|` 的计算**:
    -   这是所有“`a₁`至少拿5个 **并且** `a₂`至少拿4个”的12-组合的集合。
    -   **思想**: 同样，我们先强制满足这两个“坏”条件。
    -   预先拿出 `5` 个名额给 `a₁`，再拿出 `4` 个名额给 `a₂`。总共预分配了 `5+4=9` 个名额。
    -   我们手上还剩下 `12 - 9 = 3` 个名额需要分配。
    -   这3个名额可以任意地分配给4类物品。
    -   `|A₁ ∩ A₂| = F(4, 3) = C(4+3-1, 3) = C(6, 3) = 20`。
-   **计算其他交集**:
    -   `|A₁ ∩ A₃|`: 预分配 `5+5=10`，剩下2个名额。`F(4, 2) = C(5, 2) = 10`。
    -   `|A₂ ∩ A₃|`: 预分配 `4+5=9`，剩下3个名额。`F(4, 3) = 20`。
    -   ...以此类推。

#### **5. 计算更高阶的交集**
-   **`|A₁ ∩ A₂ ∩ A₃|` 的计算**:
    -   预分配 `5` (给`a₁`) + `4` (给`a₂`) + `5` (给`a₃`) = `14` 个名额。
    -   但是我们总共只要拿12个！名额不够了 (`14 > 12`)。
    -   这意味着，**不可能**同时满足这三个条件。
    -   所以 `|A₁ ∩ A₂ ∩ A₃| = 0`。
    -   所有更高阶的交集（三者交、四者交）也都是0。

#### **6. 代入容斥原理公式**
-   **合法方案数** = `|S| - (|A₁|+|A₂|+|A₃|+|A₄|) + (|A₁∩A₂|+...) - 0 + 0`
    `= 455 - (120+165+120+84) + (20+10+4+20+4+10) - 0 + 0`
    `= 455 - 489 + 68 = 34`。

---

### **算法化总结**

教材最后给出的两个算法，其实就是把我们上面手算的这个过程，用更形式化、更适合计算机编程的语言描述了一遍。

-   **核心逻辑**:
    1.  **第1步**: 计算**总数** `C(n+r-1, r)` (对应 `|S|`)。
    2.  **第2步**:
        -   计算所有**单项交集** `Σ|Aᵢ|`，从总数中**减去**。
        -   计算所有**两两交集** `Σ|Aᵢ∩Aⱼ|`，加回总数。
        -   计算所有**三三交集** `Σ|Aᵢ∩Aⱼ∩Aₖ|`，再减去。
        -   ...如此往复，符号 `+`, `-` 交替。
-   **计算任意交集的通用方法**:
    -   要计算 `|Aᵢ₁ ∩ Aᵢ₂ ∩ ... ∩ Aᵢₘ|`，即 `m` 个性质的交集。
    -   先计算**预分配名额** `R = (kᵢ₁+1) + (kᵢ₂+1) + ... + (kᵢₘ+1)`。
    -   如果 `R > r`，则此交集大小为0。
    -   否则，剩下 `r - R` 个名额需要分配。
    -   此交集的大小就是 `F(n, r-R) = C(n + (r-R) - 1, r-R)`。

**算法2.1和2.2的区别**：
-   **算法2.1** 是按照交集的**阶数** `m` (1个性质的交集, 2个性质的交集...)来循环。
-   **算法2.2** 是用**二进制数**来巧妙地**枚举**所有可能的**交集组合**。一个 `n` 位的二进制数，第 `i` 位是1，就代表性质 `pᵢ` 被包含在当前计算的交集中。这是一种更高效的编程实现方式。

**本节的精髓，就是通过“预分配超额部分”这个核心技巧，将一个带上限的复杂组合问题，转化成了一系列不带上限的、可以用隔板法解决的简单组合问题的加减组合。**



## **2.3 错排问题**

#### **核心问题：什么是错排？**

**通俗描述 (帽子问题)**：`n` 个人参加宴会，都把帽子存放在衣帽间。宴会结束后，服务员随机地将 `n` 顶帽子发还给 `n` 个人。问：**恰好没有一个人拿到自己帽子**的方案数有多少种？

**数学描述**:
-   我们有一个有序的集合 `{1, 2, ..., n}`。
-   它的一个**全排列**可以写成 `a₁, a₂, ..., aₙ`。
-   如果一个排列满足**对所有的 `i` (从1到n)，都有 `aᵢ ≠ i`**，那么这个排列就是一个**错排**。
-   我们用 `Dₙ` 来表示 `n` 个元素的错排数。

**举例**:
-   `n=1`: `{1}` 只有一种排列 `a₁=1`，不满足 `a₁≠1`，所以 `D₁=0`。
-   `n=2`: `{1, 2}` 有两种排列：
    -   `1, 2` (不满足 `a₁≠1` 和 `a₂≠2`)
    -   `2, 1` (满足 `a₁=2≠1` 且 `a₂=1≠2`) → 这是唯一的错排。所以 `D₂=1`。
-   `n=3`: `{1, 2, 3}` 有 `3!=6` 种排列。
    -   `1, 2, 3` (3个元素在原位)
    -   `1, 3, 2` (1在原位)
    -   `2, 1, 3` (3在原位)
    -   `3, 2, 1` (2在原位)
    -   `2, 3, 1` (全不在原位) → 错排
    -   `3, 1, 2` (全不在原位) → 错排
    -   所以 `D₃=2`。

---

### **定理 2.2：用容斥原理推导 `Dₙ` 的公式**

直接去数“全都不在”的情况很困难，所以我们再次使用容斥原理的逆向思维。

#### **1. 建模**

-   **全集 `S`**: `{1, 2, ..., n}` 的**所有**全排列。`|S| = n!`。
-   **“坏”的性质 `pᵢ`**: “第 `i` 个元素恰好在它自己的位置上”，即 `aᵢ = i`。
-   **目标**: 我们要求的是**一个“坏”性质都没有**的排列数，即 `Dₙ = |Ā₁ ∩ Ā₂ ∩ ... ∩ Āₙ|`。

#### **2. 计算交集大小**

-   **`|Aᵢ|` (至少有一个元素在原位)**:
    -   `|A₁|` 是所有 `a₁=1` 的排列。如果 `1` 的位置固定了，剩下的 `n-1` 个元素 `{2,...,n}` 可以在剩下的 `n-1` 个位置上任意全排列。
    -   所以 `|A₁| = (n-1)!`。
    -   同理，`|Aᵢ| = (n-1)!` 对所有 `i` 都成立。

-   **`|Aᵢ ∩ Aⱼ|` (至少有两个元素在原位)**:
    -   `|A₁ ∩ A₂|` 是所有 `a₁=1` 且 `a₂=2` 的排列。如果 `1` 和 `2` 的位置都固定了，剩下的 `n-2` 个元素可以在剩下的 `n-2` 个位置上任意全排列。
    -   所以 `|A₁ ∩ A₂| = (n-2)!`。
    -   同理，任意两个性质的交集大小都是 `(n-2)!`。

-   **`|Aᵢ₁ ∩ ... ∩ Aᵢₖ|` (至少有k个元素在原位)**:
    -   同理，如果我们固定 `k` 个元素的位置，剩下的 `n-k` 个元素可以任意全排列。
    -   所以 `k` 个性质的交集大小是 `(n-k)!`。

#### **3. 代入容斥原理公式**

`Dₙ = |S| - Σ|Aᵢ| + Σ|Aᵢ∩Aⱼ| - ...`

-   `Σ|Aᵢ|`: 有 `C(n,1)` 种方式选择一个性质 `pᵢ`，每种情况的大小是 `(n-1)!`。总和是 `C(n,1) * (n-1)!`。
-   `Σ|Aᵢ∩Aⱼ|`: 有 `C(n,2)` 种方式选择两个性质 `pᵢ, pⱼ`，每种情况的大小是 `(n-2)!`。总和是 `C(n,2) * (n-2)!`。
-   `Σ|...|` (`k`个性质): 有 `C(n,k)` 种方式，每种大小是 `(n-k)!`。总和是 `C(n,k) * (n-k)!`。

**代入得**:
`Dₙ = n! - C(n,1)(n-1)! + C(n,2)(n-2)! - ... + (-1)ⁿC(n,n)(n-n)!`

**化简每一项**: `C(n,k)(n-k)! = [n!/(k!(n-k)!)] * (n-k)! = n!/k!`

**得到最终公式**:
`Dₙ = n!/0! - n!/1! + n!/2! - ... + (-1)ⁿn!/n!`
`Dₙ = n! * (1/0! - 1/1! + 1/2! - 1/3! + ... + (-1)ⁿ/n!)`
`Dₙ = n! * Σ [k=0 to n] (-1)ᵏ/k!`

这就是**定理 2.2** 的公式。

---

### **与自然常数 `e` 的联系**

-   我们知道 `eˣ` 的泰勒展开式是 `Σ [k=0 to ∞] xᵏ/k!`。
-   令 `x=-1`，则 `e⁻¹ = Σ [k=0 to ∞] (-1)ᵏ/k! = 1/0! - 1/1! + 1/2! - ...`
-   我们发现，`Dₙ/n!` 的表达式 `(1/0! - 1/1! + ...)` 正是 `e⁻¹` 的泰勒展开式的前 `n+1` 项。
-   当 `n` 变得很大时，`Dₙ/n!` 的值会非常非常接近 `e⁻¹ ≈ 0.36788`。
-   **直观解释**: 随机抽取一个 `n` 个元素的全排列，当 `n` 很大时，这个排列是错排的概率大约是 `36.8%`，这个概率与 `n` 的具体大小基本无关！这是一个非常惊人的结论。

---

### **定理 2.3：`Dₙ` 的递推关系**

`Dₙ = (n-1) * (Dₙ₋₁ + Dₙ₋₂)`

这个递推关系提供了另一种计算 `Dₙ` 的方法，并且有非常漂亮的组合意义。

**组合证明**:
我们考虑 `n` 个元素的错排，特别关注元素 `1` 的位置。`a₁` 不能是 `1`，所以 `a₁` 必定是 `k`，其中 `k` 是 `{2, 3, ..., n}` 中的某个数。有 `n-1` 种选择 `k` 的方法。
我们固定 `a₁ = k`，然后分两种情况讨论元素 `k` 的位置 `aₖ`：

1.  **情况一：`aₖ = 1` (元素1和元素k“互换位置”)**
    -   `1` 去了 `k` 的位置，`k` 去了 `1` 的位置。这两个元素都得到了满足（不在自己的位置上）。
    -   剩下的 `n-2` 个元素，需要在它们自己的 `n-2` 个位置上进行错排。
    -   方案数是 `Dₙ₋₂`。
    -   因为 `k` 有 `n-1` 种选择，所以这种情况的总方案数是 `(n-1) * Dₙ₋₂`。

2.  **情况二：`aₖ ≠ 1` (元素1去了k的位置，但k没去1的位置)**
    -   `1` 去了 `k` 的位置。
    -   对于剩下的 `n-1` 个元素 `{2, 3, ..., n}` 和 `n-1` 个位置 `{2, 3, ..., n}`，我们需要进行一次“受限制”的排列。
    -   限制是：
        -   `2` 不能去位置 `2`。
        -   ...
        -   `k` 不能去位置 `1` (这是我们这个情况的假设)。
        -   ...
    -   **巧妙的转换**: 这个问题等价于一个新的错排问题。我们把位置 `1` “重新标记”为位置 `k`。现在的问题是，让 `n-1` 个元素 `{2, 3, ..., n}` 排到 `n-1` 个位置 `{2, 3, ..., "k", ..., n}` 上，要求 `2` 不在 `2`，...，**`k` 不在 "k"**，...。
    -   这正是一个 `n-1` 个元素的标准错排问题！方案数是 `Dₙ₋₁`。
    -   因为 `k` 有 `n-1` 种选择，所以这种情况的总方案数是 `(n-1) * Dₙ₋₁`。

根据加法原理，将两种情况相加，得到 `Dₙ = (n-1)Dₙ₋₂ + (n-1)Dₙ₋₁ = (n-1)(Dₙ₋₁ + Dₙ₋₂)`。

---

### **例题解析**

#### **【例8】正好有 `r` 个元素在原位**

-   这是一个**组合**与**错排**的结合。
-   **第一步 (组合)**: 从 `n` 个元素中，选出**哪 `r` 个**元素是“幸运儿”（在原位）。选择方法有 `C(n, r)` 种。
-   **第二步 (错排)**: 剩下的 `n-r` 个元素，必须**全部不在**它们自己的位置上。这正是一个 `n-r` 个元素的错排问题，方案数是 `Dₙ₋ᵣ`。
-   **结论 (乘法原理)**: 总方案数 = `C(n, r) * Dₙ₋ᵣ`。

#### **【例9】两次分书**

-   **第一步 (任意分配)**: 第一次把 `n` 本书分给 `n` 个学生，相当于给学生和书建立一个初始配对。这可以看作是 `n` 个元素的全排列，有 `n!` 种方式。
-   **第二步 (错排分配)**: 第二次分配，要求每个学生都拿到一本**和第一次不同**的书。这相当于对第一次的分配方案进行一次**错排**。方案数是 `Dₙ`。
-   **结论 (乘法原理)**: 总分配方式 = (第一次的分配方式数) × (第二次的错排方式数) = `n! * Dₙ`。



## 2.4 相对位置上有限制的排列问题

### **章节概要：相对位置上有限制的排列问题**

#### **核心问题**

**通俗描述 (小学生散步问题)**：`n` 个小学生排成一列散步。他们不喜欢每天排在自己前面的总是同一个人。问：有多少种新的排队方法，使得**每个学生前面的同学都和原来不一样**？（第一个学生除外，他前面没人）。

**数学描述**:
-   我们有一个标准的排列 `{1, 2, 3, ..., n}`。
-   在这个标准排列中，`2` 的前面是 `1`，`3` 的前面是 `2`，...，`n` 的前面是 `n-1`。
-   我们把 `12`, `23`, `34`, ..., `(n-1)n` 这些**相邻的配对**称为“**禁止的相对位置**”。
-   问题是：在 `{1, 2, ..., n}` 的所有全排列中，有多少个排列**完全不包含**任何一个上述的禁止配对？
-   我们用 `Qₙ` 来表示这个数量。

**与错排问题的区别**:
-   **错排 (绝对位置限制)**：`1` 不能在**位置1**，`2` 不能在**位置2**，...
-   **本问题 (相对位置限制)**：`1` 和 `2` 不能**相邻且`1`在`2`前**，`2` 和 `3` 不能**相邻且`2`在`3`前**，...

**举例 (n=4):**
-   标准排列: `1, 2, 3, 4`
-   禁止的配对: `12`, `23`, `34`
-   `4, 1, 3, 2` - **合法** (没有出现 `12`, `23`, `34`)
-   `1, 2, 4, 3` - **不合法** (包含了 `12`)
-   `4, 2, 3, 1` - **不合法** (包含了 `23`)

---

### **定理 2.4：用容斥原理推导 `Qₙ` 的公式**

直接计算 `Qₙ` 很困难，所以我们再次使用容斥原理。

#### **1. 建模**

-   **全集 `S`**: `{1, 2, ..., n}` 的所有全排列。`|S| = n!`。
-   **“坏”的性质 `pⱼ`**: 排列中出现了禁止的配对 `j(j+1)`。 (注意 `j` 从 `1` 到 `n-1`，共 `n-1` 种性质)。
-   **目标**: 我们要求的是**一个“坏”性质都没有**的排列数，即 `Qₙ = |Ā₁ ∩ Ā₂ ∩ ... ∩ Āₙ₋₁|`。

#### **2. 计算交集大小 (捆绑法的应用)**

-   **`|Aⱼ|` (至少出现一个禁止配对)**:
    -   `|A₁|` 是所有出现 `12` 的排列。我们可以把 `12` **捆绑**成一个“超级元素” `(12)`。
    -   问题转化为对 `{(12), 3, 4, ..., n}` 这 `n-1` 个元素进行全排列。
    -   所以 `|A₁| = (n-1)!`。
    -   同理，`|Aⱼ| = (n-1)!` 对所有 `j` 都成立。

-   **`|Aᵢ ∩ Aⱼ|` (至少出现两个禁止配对)**:
    -   **情况一 (不重叠)**: 如 `|A₁ ∩ A₃|`，即出现 `12` **和** `34`。
        -   我们把 `(12)` 和 `(34)` 都捆绑起来。
        -   问题转化为对 `{(12), (34), 5, ..., n}` 这 `n-2` 个元素进行全排列。
        -   所以 `|A₁ ∩ A₃| = (n-2)!`。
    -   **情况二 (重叠)**: 如 `|A₁ ∩ A₂|`，即出现 `12` **和** `23`。
        -   这意味着排列中必须出现 `123` 这个子序列。
        -   我们把 `(123)` 捆绑成一个“超级元素”。
        -   问题转化为对 `{(123), 4, 5, ..., n}` 这 `n-2` 个元素进行全排列。
        -   所以 `|A₁ ∩ A₂| = (n-2)!`。
    -   **结论**: 无论选择的两个性质是否重叠，`k` 个性质的交集总是把元素链式地捆绑起来，最终都等价于 `n-k` 个元素的全排列。所以任意两个性质的交集大小都是 `(n-2)!`。

-   **`k` 个性质的交集**:
    -   同理，同时具有 `k` 个选定的禁止配对的排列数，就是将这些元素捆绑后，对剩下的 `n-k` 个“超级元素”进行全排列。
    -   其大小为 `(n-k)!`。

#### **3. 代入容斥原理公式**

`Qₙ = |S| - Σ|Aᵢ| + Σ|Aᵢ∩Aⱼ| - ...`

-   `Σ|Aᵢ|`: 我们有 `n-1` 个性质 `p₁,...,pₙ₋₁`。从中选 `1` 个有 `C(n-1, 1)` 种方式。每种情况的大小是 `(n-1)!`。总和是 `C(n-1, 1) * (n-1)!`。
-   `Σ|Aᵢ∩Aⱼ|`: 从 `n-1` 个性质中选 `2` 个有 `C(n-1, 2)` 种方式。每种情况的大小是 `(n-2)!`。总和是 `C(n-1, 2) * (n-2)!`。
-   `k` 个性质的总和是 `C(n-1, k) * (n-k)!`。

**代入得**:
`Qₙ = n! - C(n-1,1)(n-1)! + C(n-1,2)(n-2)! - ... + (-1)ⁿ⁻¹C(n-1,n-1)(n-(n-1))!`

**化简每一项**: `C(n-1,k)(n-k)! = [(n-1)!/(k!(n-1-k)!)] * (n-k)!` (这个不像错排那么好化简)

**教材的最终形式**:
`Qₙ = n! - C(n-1,1)(n-1)! + C(n-1,2)(n-2)! - ...`
这个公式就是**定理 2.4**。

---

### **定理 2.5：`Qₙ` 与 `Dₙ` 的神秘联系**

`Qₙ = Dₙ + Dₙ₋₁`

这个恒等式非常优雅，它在“相对位置错排”和“绝对位置错排”之间建立了一座桥梁。证明它需要一些代数技巧，但它的**组合意义**更加深刻：

**组合证明**:
我们来数 `Qₙ` (不出现 `j(j+1)` 的排列)。我们特别关注元素 `n` 的位置。

1.  **情况一：`n` 在最后一个位置 (`aₙ = n`)**
    -   如果 `n` 在最后一个位置，那么 `(n-1)n` 这个禁止配对肯定不会出现。
    -   问题转化为：对前 `n-1` 个元素 `{1, ..., n-1}` 进行排列，要求不出现 `12, 23, ..., (n-2)(n-1)`。
    -   这正是 `Qₙ₋₁` 的定义！但是，`Qₙ₋₁` 的递推关系是 `Dₙ₋₁ + Dₙ₋₂`。
    -   *这个思路有点复杂，我们换一个更经典的证明思路。*

**更经典的组合证明**:
我们来数 `n` 个元素的**所有**排列，并根据元素 `n` 的位置分类。

-   **左边 `Qₙ`**: 我们要数的对象。
-   **右边 `Dₙ + Dₙ₋₁`**:
    -   `Dₙ` 是什么？`n` 个元素的错排。
    -   `Dₙ₋₁` 是什么？`n-1` 个元素的错排。

**构造一个一一对应**:
-   考虑一个不含 `j(j+1)` 的排列 `π` (`Qₙ` 中的一个元素)。
    -   **如果 `aₙ ≠ n`**:
        -   我们删掉 `aₙ`，然后把所有比 `aₙ` 大的数都减1。这样我们得到了一个 `n-1` 个元素的排列。可以证明，这个新排列是一个**错排** (`Dₙ₋₁` 中的一个)。
    -   **如果 `aₙ = n`**:
        -   我们直接删掉 `aₙ`。剩下的 `a₁...aₙ₋₁` 是一个对 `{1,...,n-1}` 的排列，且不含 `j(j+1)`。
-   *这个证明非常复杂，通常在更高级的教材中出现。最简单的证明方法是使用代数，证明 `Qₙ` 和 `Dₙ + Dₙ₋₁` 满足相同的递推关系。*

**递推关系证明 (最清晰)**:
-   可以证明 `Qₙ` 满足递推 `Qₙ = (n-1)Qₙ₋₁ + (n-2)Qₙ₋₂` (当n≥3)。
-   `Dₙ` 满足 `Dₙ = (n-1)(Dₙ₋₁ + Dₙ₋₂)`
-   `Dₙ + Dₙ₋₁` 也满足和 `Qₙ` 相同的递推关系，且初始值相同。因此它们相等。

---

### **【例10】旋转木马问题 (圆排列的限制)**

这是**圆排列**版本的相对位置限制问题。

-   **任务**: `n` 个儿童坐圆桌，要求每个儿童前面的都换成不同的人。
-   **标准圆排列**: `{1-2-3-...-(n-1)-n-1}` (n后面是1)。
-   **禁止的配对**: `12, 23, ..., (n-1)n, n1` (共 `n` 个)。

#### **求解过程**

-   **全集 `S`**: `n` 个元素的圆排列。`|S| = (n-1)!`。
-   **性质 `pᵢ`**: 出现 `i(i+1)` (其中 `pₙ` 代表 `n1`)。
-   **交集大小 (捆绑法)**:
    -   `|A₁|`: 出现 `12` 的圆排列。捆绑 `(12)`，相当于 `n-1` 个元素的圆排列。`|A₁| = (n-1-1)! = (n-2)!`。
    -   `k` 个性质的交集 `|Aᵢ₁ ∩ ... ∩ Aᵢₖ|`:
        -   如果这 `k` 个配对没有首尾相连形成一个完整的环（即 `k<n`），那么捆绑后相当于 `n-k` 个元素的圆排列。大小为 `(n-k-1)!`。
        -   如果这 `k` 个配对恰好是全部 `n` 个，它们连成了 `1-2-...-n-1` 这个大环，这是一个**特定的**圆排列。大小为 `1`。
-   **代入容斥原理**:
    -   `Σ|Aᵢ| = C(n,1) * (n-2)!`
    -   `Σ|Aᵢ∩Aⱼ| = C(n,2) * (n-3)!`
    -   ...
    -   最后一项是 `(-1)ⁿ|A₁∩...∩Aₙ| = (-1)ⁿ * 1`。

最终结果就是教材给出的那个复杂的求和式。这个问题是线性相对位置错排的环形推广。



## **2.5 一般有限制的排列**

### **本节核心**

本节将**容斥原理**的应用从规则的、对称的排列问题（如错排）推广到了任意的、不规则的**禁位排列问题**。为了系统性地解决这类复杂问题，本节引入了一个强大而优雅的数学工具——**棋盘多项式 (Rook Polynomial)**。

**学习路径**:
`一般禁位排列问题` → `棋盘可视化` → `棋盘多项式(工具)` → `计算棋盘多项式` → `代入容斥公式求解`

---

### **1. 核心概念：从禁位排列到棋盘多项式**

#### **1.1 一般禁位排列**

-   **问题**: `n`个元素 `{1,...,n}` 全排列，但有**任意指定**的限制条件，形如“元素 `i` 不许排在位置 `j`”。
-   **挑战**: 由于限制不规则，直接使用容斥原理计算多重交集会非常混乱。

#### **1.2 棋盘建模**

-   **思想**: 将排列问题**可视化**为一个 `n x n` 的棋盘放子问题。
    -   **行 `i`** ↔ **元素 `i`**
    -   **列 `j`** ↔ **位置 `j`**
    -   **禁位 `(i,j)`** ↔ **禁区棋盘 `C`** (所有禁止格子的集合)
-   **问题转化**: 求解在 `n x n` 棋盘上放 `n` 个互不攻击的棋子，且所有棋子都**避开**禁区棋盘 `C` 的方案数。

#### **1.3 `rₖ(C)`：关键计数对象**

-   **定义**: `rₖ(C)` 是在**仅考虑禁区棋盘 `C`** 的情况下，放置 `k` 个**互不攻击**（不同行、不同列）的棋子的方法数。
-   **作用**: `rₖ(C)` 是连接棋盘模型和容斥原理的**桥梁**。它系统地计算了容斥原理中 `k` 重交集的组合部分。

#### **1.4 定义 2.1: 棋盘多项式 `R(C, x)`**

-   **定义**: `R(C, x) = Σ [k=0 to n] rₖ(C) * xᵏ`
-   **本质与作用 (结合我们的讨论)**:
    1.  **信息档案袋**: `R(C,x)` 是一个**生成函数**，它将 `r₀, r₁, r₂, ...` 这一整串独立的数值，**编码**并**组织**成一个单一的代数对象。`xᵏ` 仅仅是一个**标签**，用于标记其系数 `rₖ` 是关于放置 `k` 个棋子的信息。
    2.  **代数计算代理**: 我们可以通过简单的**多项式运算**（加法、乘法）来操纵 `R(C,x)`，从而间接地完成对所有 `rₖ` 值的复杂计算。

---

### **2. 计算棋盘多项式的两大工具**

直接计算 `rₖ` 很困难，我们通常通过分解棋盘来计算其多项式。

#### **2.1 定理 2.6: 递归分解法 (通用算法)**

-   **公式**: `R(C, x) = x * R(Cᵢ, x) + R(Cₑ, x)`
-   **图解与思想**:
    1.  在棋盘 `C` 中**指定**一个特殊格子 `s`。
    2.  **分类讨论**:
        -   **情况A: `s` 上放棋子**:
            -   **操作**: 划掉 `s` 所在的**整行整列**。
            -   **得到**: 子棋盘 `Cᵢ`。
            -   **对应多项式**: `x * R(Cᵢ, x)`。`x` 的出现是为了**代数地处理**“问题规模减1” (`k` → `k-1`) 导致的系数下标偏移。
        -   **情况B: `s` 上不放棋子**:
            -   **操作**: 只划掉 `s` 格子**本身**。
            -   **得到**: 子棋盘 `Cₑ`。
            -   **对应多项式**: `R(Cₑ, x)`。
-   **应用**: 这是一个**分治**策略，将大棋盘不断分解为已知的小棋盘（如 `□` 或 `□□`），最终求得解。

#### **2.2 定理 2.7: 独立子棋盘定理 (高效技巧)**

-   **定义 2.2 (独立)**: 两个子棋盘 `C₁` 和 `C₂` 如果**不共享任何行或列**，则称它们是独立的。
-   **公式**: `R(C, x) = R(C₁, x) * R(C₂, x)`
-   **思想**:
    -   若棋盘可分解为独立的 `C₁` 和 `C₂`，则在 `C₁` 上的任何合法放法都可以和 `C₂` 上的任何合法放法自由组合。
    -   这种组合关系在系数层面表现为**卷积**，在多项式层面则直接体现为**乘法**。
-   **应用**: 当一个棋盘可以通过行列重排，分割成几个“井水不犯河水”的块时，此法极为高效。

---

### **3. 最终联结：从棋盘多项式回到禁位排列**

#### **3.1 定理 2.8: 禁位排列主公式**

-   **公式**: `N = n! - r₁*(n-1)! + r₂*(n-2)! - ... = Σ [k=0 to n] (-1)ᵏ * rₖ(C) * (n-k)!`
-   **证明逻辑 (容斥原理)**:
    1.  **框架**: `N = |S| - Σ|Aᵢ| + Σ|Aᵢ∩Aⱼ| - ...`
    2.  **关键桥梁**: 证明了 `k` 重交集的总和 `Σ|A_{i_1} \cap \dots| = rₖ(C) * (n-k)!`。
        -   `rₖ(C)` 计算了“**第一步**”：在禁区内选择 `k` 个互相兼容的冲突位置。
        -   `(n-k)!` 计算了“**第二步**”：排列剩下的 `n-k` 个元素。
    3.  **代入**: 将此桥梁关系代入容斥原理的框架，即得最终公式。

---

### **4. 实例应用总结**

| 例子         | 核心问题     | 禁区棋盘 `C` 的特点 | 求解 `R(C,x)` 的关键方法                                   | 最终结论                                   |
| :----------- | :----------- | :------------------ | :--------------------------------------------------------- | :----------------------------------------- |
| **【例15】** | 老师教课     | 不规则形状          | **递归分解法 (定理 2.6)**                                  | `N = 4! - 6*3! + 11*2! - 7*1! + 1*0! = 4`  |
| **【例16】** | **错排问题** | 主对角线            | **独立子棋盘定理 (定理 2.7)**, `C` 分解为 `n` 个独立的 `□` | 重新推导出 `Dₙ` 的经典公式                 |
| **【例17】** | 4对夫妇圆桌  | 环形对角线          | **递归分解法 (定理 2.6)** (计算繁琐)                       | `总数 = (4-1)! * N = 6 * 2 = 12`           |
| **【例18】** | n对夫妇圆桌  | 环形对角线 (推广)   | **问题转化**: 将`rₖ`的计算转化为**不相邻组合**问题         | 得到一个包含复杂组合数的`rₖ`通项，代入求解 |

---
### **本节学习要点**

-   **首要目标**: 掌握解决一般禁位排列问题的**标准化流程**：`建模→画棋盘→算多项式→代入公式`。
-   **核心技能**: 熟练运用**递归分解法**和**独立子棋盘定理**来计算棋盘多项式。
-   **深刻理解**: 明白**棋盘多项式**是作为**生成函数**的角色，其系数 `rₖ` 是连接**几何形状(棋盘)**和**容斥原理(代数)**的桥梁。
-   **分清主次**: 对于初学者，掌握到【例15】和【例16】的水平是核心要求。【例17】和【例18】展示了该方法处理更复杂问题的潜力，理解其解题思路和模型转化比掌握完整计算更重要。
