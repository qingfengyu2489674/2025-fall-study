## 2.1 例子语言

本节通过一系列具体实例，展示了如何使用有限的**形成规则 (文法)** 来精确定义和生成一个（可能是无限的）语言。核心在于利用**递归 (Recursion)** 从基础句子构建复杂句子。本节介绍了三种描述方式：自然语言、BNF范式和本书后续采用的**产生式**。

### 2.1.1 括号匹配串的语言

*   **目标**: 定义由匹配的圆括号构成的所有字符串的集合。
*   **产生式**:
    ```
    S → ()
    S → SS
    S → (S)
    ```
    *   **解读**: 一个合法的括号串 (`S`)，可以是基础的 `()`，或是两个合法串的**拼接** (`SS`)，或是在一个合法串外进行**嵌套** (`(S)`)。

### 2.1.2 由偶数个0组成的串的语言

*   **目标**: 定义由偶数个 `0` 构成的所有非空字符串的集合。
*   **产生式**:
    ```
    S → 00
    S → 00S
    ```
    *   **解读**: 最短的句子是 `00` (`S → 00`)，更长的句子可以通过在已有句子的基础上再添加 `00` (`S → 00S`) 得到，从而确保 `0` 的个数始终为偶数。

### 2.1.3 算术表达式的语言

*   **目标**: 定义包含变量 `i` 和运算符 `+`, `-`, `*`, `/` 的算术表达式。
*   **核心挑战**: 解决**歧义性 (Ambiguity)**，确保文法能正确反映运算符的**优先级 (Precedence)** 和**结合性 (Associativity)**。
*   **无歧义产生式**:
    ```
    E → E + T | E - T | T
    T → T * F | T / F | F
    F → (E) | i
    ```
    *   **解读**: 通过引入不同层次的非终-结符（`E`表达式, `T`项, `F`因子），建立了 `E ⇒ T ⇒ F` 的推导层级。优先级低的运算符 (`+`, `-`) 在高层规则中，优先级高的 (`*`, `/`) 在低层规则中，从而强制实现“先乘除后加减”。**左递归** `E → E + T` 则确保了运算符的**左结合性**。

### 2.1.4 标识符的语言

*   **目标**: 定义以字母开头，后跟任意字母或数字的字符串（即编程中的变量名）。
*   **产生式**:
    ```
    I → L | IL | ID
    L → a | b | ... | z
    D → 0 | 1 | ... | 9
    ```
    *   **解读**: 标识符 (`I`) 的推导必须以基础规则 `I → L` 为起点（或递归链条的终点），确保了**首字符为字母**。递归规则 `I → IL` 和 `I → ID` 允许在其后追加任意数量的字母或数字。

### 2.1.5 C语言简单变量说明语句的语言

*   **目标**: 定义C语言中简单变量的声明语句。
*   **核心思想**: 展示文法的**组合性 (Composability)** 和**模块化 (Modularity)**。
*   **产生式**:
    ```
    S → S P | P
    P → T V;
    T → int | char | float | double
    V → V, I | I
    I → ... (复用标识符的规则)
    ```
    *   **解读**: 将复杂的声明语法**自顶向下**分解为独立的模块：声明列表 (`S`)、单条声明 (`P`)、类型 (`T`)、变量列表 (`V`) 和标识符 (`I`)。每个模块只负责一项单一的功能，然后通过组合（如 `P → T V;`）构建出完整的语法结构，极大地提高了文法的清晰度和可维护性。



## 2.2 文法和语言的关系

本节阐述了形式语言理论的一个根本性问题：如何用**有限的手段**去描述一个**无限的集合**，并确立了**文法 (Grammar)** 在其中的核心地位。

*   **问题的提出：有限 vs. 无限**
    *   **有穷语言**: 描述简单，可以直接**枚举（列举）**出所有句子。
    *   **无穷语言**: 包含无限个句子，无法枚举。这是理论研究的核心挑战，必须为其寻找一种**有限的描述方式**。

*   **解决思路：从句子到规则**
    *   解决方案是转变视角，不再关注语言中无限的、单个的句子，而是去研究和提炼所有句子共同遵守的**一般构成规律**和**结构特征**。

*   **核心工具：文法 (Grammar)**
    *   **文法**被正式提出，作为无穷语言的**“有穷描述”**。它是一套有限的、精确的形成规则。
    *   文法具有两大核心功能：
        1.  **描述性**: 能清晰地描述出语言的内在结构特征。
        2.  **生成性**: 能作为一套“生成系统”，产生出该语言中所有的、且仅有的合法句子。

*   **结论：文法是语言的定义**
    *   在形式语言理论中，**文法是语言的定义**。它是连接我们**有限的认知/计算能力**与**无限的语言集合**之间的桥梁，使得对无穷语言的精确分析和计算机处理成为可能。



### 2.2.1 文法

本节为**文法 (Grammar)** 提供了严格的数学定义，并阐述了其核心的动态过程——**推导 (Derivation)**。文法是描述语言的静态蓝图，而推导是使用该蓝图生成句子的动态建造过程。

#### 2.2.1.1 文法的形式化定义

文法 `G` 被定义为一个四元组 `G = (Σ, V, S, P)`：
1.  **Σ (Terminals)**: **终结符**集合，即语言的字母表，是构成最终句子的基本构件，不可再被替换。
2.  **V (Non-terminals)**: **非终结符**集合，代表语法中的抽象概念或变量，在推导过程中必须被替换。
3.  **S (Start Symbol)**: **开始符号**，一个特殊的非终结符，是所有推导过程的唯一起点。
4.  **P (Productions)**: **产生式**集合，形如 `α → β` 的重写规则。
    *   **左部 `α`**: 至少包含一个非终结符。
    *   **右部 `β`**: 由终结符和非终结符构成的任意字符串。

#### 2.2.1.2 推导的形式化定义

推导是利用产生式将句型进行变换的过程。

*   **一步推导 (`=>`)**: 若 `α → β` 是一个产生式，则句型 `pαr` 可一步推导为 `pβr`。其逆过程称为**归约 (Reduction)**。
*   **多步/任意步推导 (`=>⁺` / `=>*`)**:
    *   `y =>⁺ z` (**正闭包**): `y` 经过**至少一步**推导得到 `z`。
    *   `y =>* z` (**克林闭包**): `y` 经过**零步或多步**推导得到 `z`。
*   **句型、句子与语言**:
    *   **句型 (Sentential Form)**: 从开始符号 `S` 出发可推导出的**任何**字符串 (`S =>* α`)，可能包含非终结符（半成品）。
    *   **句子 (Sentence)**: **只包含终结符**的句型 (`S =>* w` 且 `w ∈ Σ*`)（最终成品）。
    *   **语言 L(G)**: 由文法 `G` 生成的**所有句子**的**集合**。

#### 2.2.1.3 推导策略

当句型中存在多个非终结符时，推导策略规定了替换的顺序。

*   **最左推导 (Leftmost Derivation)**: 每一步总是替换**最左边**的非终结符。它对应于 **LL (自顶向下)** 解析器的工作模式。
*   **最右推导 (Rightmost / Canonical Derivation)**: 每一步总是替换**最右边**的非终结符。它的**逆过程**对应于 **LR (自底向上)** 解析器的工作模式，因此也被称为**规范推导**。