## 1.1 集合及其运算

本节内容是《形式语言与自动机理论》的数学基石，旨在为后续理论学习提供一套精确、统一的数学语言。核心是定义**集合 (Set)** 的基本概念、表示方法、集合间的关系以及核心运算。

### 1.1.1 集合的基本概念

- **定义**: 集合 (Set) 是由一些**不重复**的对象（称为**元素 Element**）构成的总体。
- **核心性质**:
  1.  **互异性**: 集合中没有重复的元素。如 `{1, 2, 2}` 等同于 `{1, 2}`。
  2.  **无序性**: 元素排列顺序不影响集合本身。如 `{a, b, c}` 等同于 `{c, b, a}`。
  3.  **确定性**: 任何一个对象，要么属于集合，要么不属于，不存在模棱两可。
- **基本符号**:
  - `A, B, C...`: 通常用大写字母表示集合。
  - `a, b, x...`: 通常用小写字母表示元素。
  - `x ∈ A`: 元素 `x` **属于**集合 `A`。
  - `x ∉ A`: 元素 `x` **不属于**集合 `A`。
  - `Ø` 或 `{}`: **空集 (Empty Set)**，不包含任何元素的集合。
  - `|A|`: 集合 `A` 的**基数 (Cardinality)**，即有穷集合中元素的个数。例如 `|Ø| = 0`。

### 1.1.2 集合的描述方法

描述一个集合主要有两种方式：

1.  **列举法 (Roster Notation)**
    - **方法**: 将所有元素一一列出，并用花括号 `{}` 括起来。
    - **适用**: 元素数量较少的**有穷集合 (Finite Set)**。
    - **示例**: `D = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}`

2.  **描述法/命题法 (Set-Builder Notation)**
    - **方法**: 通过描述集合元素所共有的属性来定义集合。
    - **格式**: `{x | P(x)}`，读作“所有满足谓词（属性）`P(x)` 的元素 `x` 所构成的集合”。
    - **适用**: 元素数量众多的有穷集合或**无穷集合 (Infinite Set)**。
    - **示例**: `{n | n mod 2 = 0}` 表示所有偶数的集合。

### 1.1.3 集合间的关系与运算

#### 1.1.3.1 子集 (Subset)

- **子集 (Subset, `⊆`)**: 若集合 `A` 的所有元素都属于集合 `B`，则称 `A` 是 `B` 的子集，记作 `A ⊆ B`。
  - 任何集合是其自身的子集 (`A ⊆ A`)。
  - 空集是任何集合的子集 (`Ø ⊆ A`)。
- **真子集 (Proper Subset, `⊂`)**: 若 `A ⊆ B` 且 `A ≠ B`（即 `B` 中至少有一个元素不属于 `A`），则称 `A` 是 `B` 的真子集，记作 `A ⊂ B`。
- **集合相等 (Equality, `=`)**: 两个集合 `A` 和 `B` 相等，当且仅当 `A ⊆ B` 且 `B ⊆ A`。

#### 1.1.3.2 基本运算

- **并集 (Union, `∪`)**: 由属于 `A` **或**属于 `B` 的所有元素构成的集合。
  - `A ∪ B = {x | x ∈ A ∨ x ∈ B}`
- **交集 (Intersection, `∩`)**: 由**同时**属于 `A` **和** `B` 的所有元素构成的集合。
  - `A ∩ B = {x | x ∈ A ∧ x ∈ B}`
- **差集 (Difference, `-`)**: 由属于 `A` **但**不属于 `B` 的所有元素构成的集合。
  - `A - B = {x | x ∈ A ∧ x ∉ B}`
- **补集 (Complement)**: 是差集的特例。若 `B ⊆ A`，则 `A - B` 称为 `B` 关于全集（论域） `A` 的补集。

### 1.1.4 高级运算

#### 1.1.4.1 幂集 (Power Set)

- **定义**: 集合 `A` 的**所有子集**所构成的集合，记作 `2ᴬ`。
  - `2ᴬ = {B | B ⊆ A}`
- **重要特性**:
  - 幂集的**元素本身也是集合**。
  - `Ø` 和 `A` 自身都是 `2ᴬ` 的元素。
  - 若 `|A| = n`，则 `|2ᴬ| = 2ⁿ`。
- **示例**: 若 `A = {1, 2}`，则 `2ᴬ = { Ø, {1}, {2}, {1, 2} }`。
- **后续应用**: 在非确定性有限自动机 (NFA) 中，状态转移函数的目标集合是状态集的幂集。

#### 1.1.4.2 笛卡儿积 (Cartesian Product)

- **定义**: 由两个集合 `A` 和 `B` 的元素构成的所有**有序对 (Ordered Pair)** `(a, b)` 的集合，记作 `A × B`。
  - `A × B = {(a, b) | a ∈ A ∧ b ∈ B}`
- **重要特性**:
  - 结果的元素是**有序的**，`a` 在前，`b` 在后。
  - 一般情况下，`A × B ≠ B × A`。
  - 若 `|A| = m` 且 `|B| = n`，则 `|A × B| = m × n`。
- **示例**: 若 `A = {a, b}`，`B = {0, 1}`，则 `A × B = {(a, 0), (a, 1), (b, 0), (b, 1)}`。
- **后续应用**: 自动机的**状态转移函数** `δ` 通常被定义为笛卡儿积上的映射，例如 `δ: Q × Σ → Q`，其定义域为 `(状态, 输入符号)` 的有序对集合。



## 1.2 关系 (Relation)

本节在集合论的基础上，引入了描述元素之间联系的数学工具——**关系**。重点介绍了关系的定义、一种特殊且重要的关系（等价关系），以及关系的核心运算（合成与闭包）。这些概念，特别是**闭包**，是形式语言和自动机理论的基石。

### 1.2.1 关系的定义

- **定义**: 从集合 `A`到集合 `B` 的一个**二元关系 (Binary Relation)** `R`，是笛卡儿积 `A × B` 的任意一个**子集**。
  - `R ⊆ A × B`
- **表示法**: 如果有序对 `(a, b)` 属于关系 `R`，即 `(a, b) ∈ R`，我们通常记作 `aRb`。
- **A上的关系**: 若 `A = B`，则称 `R` 是集合 `A` 上的一个关系 (`R ⊆ A × A`)。
- **示例**: "小于"关系 `<` 在正整数集合 `N` 上，就是集合 `{(a, b) | a, b ∈ N ∧ a < b}`。

### 1.2.2 等价关系 (Equivalence Relation)

等价关系是一种模拟 "等于" 行为的特殊关系，它必须同时满足以下三个性质：
1.  **自反性 (Reflexive)**: 对任意 `a ∈ A`，都有 `aRa`。 (自己等于自己)
2.  **对称性 (Symmetric)**: 若 `aRb`，则必有 `bRa`。 (你等于我，我也等于你)
3.  **传递性 (Transitive)**: 若 `aRb` 且 `bRc`，则必有 `aRc`。 (传递性)

- **核心性质：划分 (Partition)**
  - 一个集合 `A` 上的等价关系 `R`，可以将 `A` **划分**成若干个互不相交的子集，这些子集被称为**等价类 (Equivalence Class)**。
  - **等价类 `[a]`**: 由集合 `A` 中所有与 `a` 存在等价关系的元素组成的集合，即 `[a] = {b ∈ A | aRb}`。
  - **指数 (Index)**: 等价类的总数。
- **应用预告**: 在自动机理论中，**状态等价性**是一个核心概念，用于**最小化自动机**。

### 1.2.3 关系的运算：合成与闭包

#### 1.2.3.1 关系合成 (Composition)

- **定义**: 设 `R₁ ⊆ A × B`，`R₂ ⊆ B × C`，它们的合成 `R₁ ∘ R₂` 是一个从 `A` 到 `C` 的关系。
  - `R₁ ∘ R₂ = {(a, c) | 存在 b∈B，使得 (a, b) ∈ R₁ 且 (b, c) ∈ R₂}`
- **含义**: 通过中间元素 `b` 作为“桥梁”，建立 `a` 到 `c` 的连接。

#### 1.2.3.2 关系的幂 (Power)

- **定义**: 关系 `R` 的 `n` 次幂 `Rⁿ` 表示通过 `R` 进行 `n` 次连续合成。
  - `R⁰ = {(a, a) | a ∈ S}` (恒等关系，走0步)
  - `Rⁿ = R ∘ Rⁿ⁻¹` (递归定义)
- **含义**: `Rⁿ` 表示通过关系 `R` 走 `n` 步能建立的所有连接。

#### 1.2.3.3 关系闭包 (Closure)

闭包是基于某个初始关系 `R`，通过反复应用某种规则（如传递性）所能得到的所有关系对的“完整”集合。

- **正闭包 (Positive Closure, `R⁺`)**:
  - **定义**: `R⁺ = R¹ ∪ R² ∪ R³ ∪ ... = ⋃ᵢ<binary data, 19 bytes>₁ Rⁱ`
  - **含义**: 表示通过**至少一步** (`1` 次或多次) 关系 `R` 可以建立的所有连接。也称为**传递闭包 (Transitive Closure)**。
  - **对应**: 正则表达式中的 `+` 运算符。

- **克林闭包 (Kleene Closure, `R*`)**:
  - **定义**: `R* = R⁰ ∪ R⁺ = R⁰ ∪ R¹ ∪ R² ∪ ... = ⋃ᵢ<binary data, 20 bytes>₀ Rⁱ`
  - **含义**: 表示通过**零步或多步** (`0` 次或多次) 关系 `R` 可以建立的所有连接。
  - **对应**: 正则表达式中的 `*` 运算符，是**形式语言理论的基石**之一。



## 1.3 证明和证明的方法

本节为理论性极强的《形式语言与自动机》课程提供了必备的逻辑工具。内容从“知识”转向“方法”，重点介绍了两种在该领域中应用最广泛的证明技巧：**反证法**和**数学归纳法**，并强调了**归纳证明**与**递归定义**之间的紧密联系。

### 1.3.1 反证法 (Proof by Contradiction)

反证法，或称归谬法，是一种间接证明方法。

- **核心逻辑**:
  1.  **反向假设**: 假设要证明的命题**不成立**。
  2.  **逻辑推导**: 基于此假设进行一系列严格的逻辑推理。
  3.  **导出矛盾**: 推理最终会得出一个与已知条件、公理、已证定理或假设本身相**矛盾**的结论。
  4.  **肯定原命题**: 既然错误的假设导致了矛盾，那么该假设必然是错误的。因此，原命题必须为真。

- **适用场景**: 当直接证明一个命题比较困难，但否定该命题会引出清晰的限制条件时，反证法尤为有效。

### 1.3.2 归纳法 (Proof by Induction)

数学归纳法是证明“一个与自然数 `n` 相关的命题 `P(n)` 对所有（或从某个初始值 `N` 开始的所有）`n` 都成立”的强大工具。它用有限的步骤证明无限的情况。

- **核心逻辑 (多米诺骨牌效应)**:
  1.  **归纳基础 (Base Case)**: 证明命题在**起始点** `n=N` 时成立。 (推倒第一块骨牌)
  2.  **归纳步骤 (Inductive Step)**:
      - **归纳假设 (Inductive Hypothesis)**: **假设**命题对任意 `k ≥ N` 成立，即 `P(k)` 为真。 (假设第k块骨牌会倒)
      - **归纳证明**: 在上述假设下，证明命题对 `k+1` 也成立，即 `P(k+1)` 为真。 (证明第k块倒下必然会推倒第k+1块)

- **结论**: 完成以上两步，即可断定该命题对所有 `n ≥ N` 成立。

### 1.3.3 递归的定义与归纳证明

本部分揭示了**递归 (Recursion)** 和**归纳 (Induction)** 作为“一体两面”的深刻联系。

- **递归定义 (Recursive Definition)**: 一种**构造性**的定义方法，常用于定义集合或结构。
  1.  **基础 (Basis)**: 定义集合中最基本、最原始的元素。
  2.  **递归 (Recursion)**: 提供一套规则，说明如何从集合中**已有**的元素生成**新**的元素。
  3.  **有限性/闭包 (Closure)**: 声明只有通过前两条规则生成的元素才属于该集合。

- **归纳证明 (Inductive Proof)**: 一种**验证性**的证明方法，常用于证明由递归定义的集合的所有元素都具有某种性质。
  1.  **基础**: 证明**基础元素**具有该性质 `P`。
  2.  **归纳**: 证明如果**已有元素**具有性质 `P`，那么通过**递归规则**生成的**新元素**也必然具有性质 `P`。

- **关系**: 递归定义了对象的“生成”过程，而归纳法则顺着这个生成过程去“检验”性质是否得以保持。两者完美契合，是理论计算机科学中定义和证明的核心组合。例如，用递归定义“括号匹配的字符串”，再用归纳法证明其性质。



## 1.4 图与树

本节介绍两种在计算机科学中应用极为广泛的数学结构：**图 (Graph)** 和 **树 (Tree)**。它们是用于建模对象及其之间关系的强大工具。对于本课程，**有向图**是描述有限自动机的标准可视化模型，而**树**则是表示形式语言句子结构（如语法分析树）的基础。

### 1.4.1 图 (Graph)

图是一种由顶点（节点）和连接顶点的边组成的结构。

- **基本构成**: `G = (V, E)`
  - `V`: **顶点集 (Vertex Set)**，表示研究的对象或实体（如自动机的状态）。
  - `E`: **边集 (Edge Set)**，表示顶点之间的关系（如状态间的转移）。

#### 1.4.1.1 无向图 (Undirected Graph)
- **定义**: 边集 `E` 中的边 `(u, v)` 是无方向的，` (u, v)` 和 `(v, u)` 代表同一条边。
- **类比**: 双向街道、社交网络中的好友关系。

#### 1.4.1.2 有向图 (Directed Graph / Digraph)
- **定义**: 边集 `E` 中的边 `(u, v)` 是有方向的，表示一个从 `u` 指向 `v` 的箭头。` (u, v)` 和 `(v, u)` 是两条不同的边。
- **术语**:
  - `u` 是 `v` 的**前导 (Predecessor)**。
  - `v` 是 `u` 的**后继 (Successor)**。
- **核心应用**: **有限自动机**的状态转换图就是一个典型的有向图。

### 1.4.2 有向图中的路径

- **有向路 (Directed Path)**: 在有向图中，沿着边的方向从一个顶点到另一个顶点经过的顶点序列。
  - **应用**: 在自动机中，一条从开始状态到接受状态的路径，对应一个被识别的字符串。
- **有向回路 (Directed Cycle)**: 起点和终点相同的有向路，形成一个环。
  - **应用**: 在自动机中，回路用于识别重复模式，直接对应正则表达式中的**克林闭-包 (`*`)** 和**正闭包 (`+`)**。

### 1.4.3 树 (Tree)

树是一种特殊的、具有严格层次结构的有向图。

- **定义**: 一棵树是一个满足以下三个条件的有向图 `G = (V, E)`:
  1.  **唯一的根 (Root)**: 存在一个没有前导的顶点（**根节点**），并且从根节点到图中任何其他顶点都存在有向路。
  2.  **唯一的父亲 (Unique Parent)**: 每个非根顶点有且仅有一个前导。这个性质保证了树是**无环的 (Acyclic)**。
  3.  **后继有序 (Ordered Successors)**: 每个顶点的后继（儿子）按从左到右的顺序排列。

- **常用术语**:
  - **节点 (Node)**: 树中的顶点。
  - **父亲 (Parent)** / **儿子 (Child)**: 节点的前导/后继。
  - **祖先 (Ancestor)** / **后代 (Descendant)**: 路径上的前辈/晚辈。
  - **叶子节点 (Leaf Node)**: 没有儿子的节点。
  - **中间节点 (Internal Node)**: 非根、非叶子的节点。

- **核心应用**: 在编译器理论中，用**语法分析树 (Parse Tree)** 来表示源代码的语法结构。



## 1.5 语言 (Language)

本节正式引入了《形式语言与自动机》课程的核心研究对象。它通过三个层次化的概念——**字母表、字符串、语言**——构建了形式语言的理论基础，并提出了贯穿全书的三个核心研究问题。

### 1.5.1 基本定义

形式语言的体系由三个基本构件自下而上构成：

1.  **字母表 (Alphabet, Σ)**
    - **定义**: 一个**非空的、有穷的**符号**集合**。
    - **作用**: 它是构成语言所有内容的基本元素库。
    - **示例**: 二进制字母表 `Σ = {0, 1}`；小写英文字母表 `Σ = {a, b, ..., z}`。

2.  **字符串 (String)**
    - **定义**: 字母表中符号的一个**有穷序列**。
    - **特性**: 序列是有序的，因此 `"ab"` 和 `"ba"` 是不同的字符串。
    - **空串 (Empty String, ε)**: 长度为零的特殊字符串，是理论中的重要基础元素。

3.  **语言 (Language, L)**
    - **核心定义**: 一个**字符串的集合**。
    - **关系**: 任何在字母表 `Σ` 上定义的语言 `L`，都是由 `Σ` 上所有可能字符串构成的全集 `Σ*` 的一个**子集** (`L ⊆ Σ*`)。
    - **分类**:
        - **有穷语言**: 包含有限个字符串，可以用列举法表示。
        - **无穷语言**: 包含无限个字符串，必须用一套**有限的规则**来描述。

### 1.5.2 本课程的核心研究问题

本课程围绕语言展开，旨在回答以下三个根本性问题：

1.  **语言的表示 (Representation)**:
    - **问题**: 如何用**有限的工具**（如规则、机器）去精确**描述**一个可能是无限的语言？
    - **答案**: 通过学习**有限自动机、正则表达式、形式文法**等模型。

2.  **语言的可描述性 (Describability)**:
    - **问题**: 是否所有语言都存在有限的描述方法？
    - **答案**: 否。这引出了**可计算性理论**的边界，即有些语言（问题）是无法用任何算法模型来判定的。

3.  **语言的结构与特性 (Structure & Properties)**:
    - **问题**: 具有有限表示的语言，其内部结构是怎样的？它们有哪些共同性质？如何根据复杂性对它们进行分类？
    - **答案**: 通过研究**乔姆斯基谱系 (Chomsky Hierarchy)** 中的不同语言家族（如正则语言、上下文无关语言等）及其性质。



## 1.7 形式语言与自动机的发展

本节从历史视角回顾了《形式语言与自动机》这门学科的诞生、核心思想、关键人物及重大影响。

*   **两大思想源头**:
    1.  **生成 (Generation) 视角**: 由语言学家**乔姆斯基 (Chomsky)** 提出，使用**文法 (Grammar)** 定义一套有限的推导规则，来**生成**一个语言中的所有合法句子。
    2.  **识别 (Recognition) 视角**: 由数学家**克林 (Kleene)** 提出，使用**自动机 (Automata)** 这一抽象计算模型，来**识别**一个给定的字符串是否属于某个语言。

*   **理论的诞生**: 学科的真正诞生源于**乔姆斯基证明了“文法”和“自动机”之间的等价性**。这意味着对于特定类别的语言，生成它的文法和识别它的自动机是一一对应的，可以相互转换。

*   **核心成果与验证 (乔姆斯基谱系)**: 该理论最核心的成果是建立了文法与自动机之间完美的对应关系，即乔姆斯基谱系 (Chomsky Hierarchy)，它根据复杂性将语言和计算模型划分为四个层级：
    *   **0型文法** (无限制文法) ↔️ **图灵机**
    *   **1型文法** (上下文有关文法) ↔️ **线性有界自动机**
    *   **2型文法** (上下文无关文法) ↔️ **下推自动机**
    *   **3型文法** (正则文法) ↔️ **有限状态自动机**

*   **在计算机科学中的应用与意义**:
    *   **程序设计语言**: **2型文法**（通过BNF范式）成为描述几乎所有高级程序设计语言语法的理论基础。
    *   **词法分析与搜索**: **3型文法**是正则表达式和编译器词法分析器的理论核心。
    *   **理论边界**: 该理论证明了计算机科学中的一些根本性问题，例如“任意上下文无关文法的歧义性是不可判定的”，为计算能力划定了理论边界。
    *   **思维培养**: 本课程是培养计算机专业学生**计算思维、抽象能力和逻辑推理能力**的基石。