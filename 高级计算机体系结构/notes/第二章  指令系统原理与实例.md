## **2.1 简介**

本节回顾了第一章中提到的三大应用领域，并从**指令集系统 (ISA)** 的角度分析了它们各自的设计侧重点。

#### 一、 三大应用领域的指令集需求

1.  **桌面/科学计算领域**:
    -   注重**定点和浮点运算性能**。
    -   不注重程序（代码）大小及处理器功耗。

2.  **服务器领域**:
    -   主要应用于数据库、文件服务器、Web应用。
    -   注重**定点和字符串处理**性能。
    -   有浮点指令，但其性能不是关键。

3.  **嵌入式领域**:
    -   注重**成本、功耗和代码大小**。
    -   一些复杂指令（如浮点指令）通常作为**可定制的选项**，以控制成本。

#### 二、 核心结论与本章重点

-   **指令集的相似性**: 尽管这三个领域的侧重点不同，但它们的**指令系统仍然非常相似**，共享一个核心基础。

-   **本章学习重点**: 正因为这种相似性，**MIPS 指令集**成为了一个经典的教学和研究案例，因为它在**桌面、服务器和嵌入式**这三个领域中都有着广泛的应用。本章将以 MIPS 为例展开学习。



## **2.2 指令集系统结构的分类**

#### 一、 分类的根本区别

**指令集系统结构 (ISA)** 最根本的区别在于**处理器内部数据的存储结构不同**。这种存储结构决定了指令如何指定其操作数。

-   **内部存储结构**: 主要分为**堆栈 (Stack)**、**累加器 (Accumulator)** 或**一组通用寄存器 (a set of general-purpose registers)**。
-   **操作数指定方式**:
    -   **隐式指定 (Implicit)**: 指令的操作数位置是约定俗成的，不需要在指令中明确指出。
    -   **显式指定 (Explicit)**: 指令中必须明确指出操作数所在的寄存器或内存地址。

#### 二、 四种主要的 ISA 类型

根据内部存储结构，ISA 主要可以分为以下四种类型：

##### (1) 堆栈体系结构 (Stack Architecture)
-   **工作原理**: 所有ALU操作的操作数都**隐式地**位于**栈顶**。
-   **数据流**:
    1.  两个操作数从栈顶弹出，送入ALU。
    2.  ALU进行运算。
    3.  运算结果被压回栈顶。
-   **内存交互**: 通过 `Push`（压栈）和 `Pop`（弹栈）指令与主存进行数据交换。
-   **特点**: 指令非常紧凑，但难以进行乱序执行等优化。

##### (2) 累加器体系结构 (Accumulator Architecture)
-   **工作原理**: 其中一个操作数**隐式地**是**累加器 (Accumulator)** 这个专用寄存器。
-   **数据流**:
    1.  一个操作数来自累加器，另一个来自主存。
    2.  ALU进行运算。
    3.  运算结果**隐式地**存回累加器。
-   **特点**: 指令简单，但累加器成为性能瓶颈，内存流量较大。

##### (3) 寄存器-存储器体系结构 (Register-Memory Architecture)
-   **工作原理**: 操作数被**显式指定**。ALU操作允许一个操作数在寄存器中，另一个在主存中。
-   **数据流**:
    1.  一个操作数来自寄存器，一个来自主存。
    2.  ALU进行运算。
    3.  运算结果存回寄存器。
-   **特点**: 指令格式更复杂，操作数长度不一，不利于流水线设计。

##### (4) 寄存器-寄存器 (Load-Store) 体系结构 (Register-Register or Load-Store Architecture)
-   **工作原理**: 所有ALU操作的操作数都必须**显式地**位于**通用寄存器**中。
-   **数据流**:
    1.  所有操作数都来自寄存器。
    2.  ALU进行运算。
    3.  运算结果存回寄存器。
-   **内存交互**: 只能通过专门的 `Load` (从内存加载到寄存器) 和 `Store` (从寄存器存储到内存) 指令与主存交互。
-   **特点**: 指令格式规整，执行速度快，易于编译器优化和硬件流水线设计。**现代大多数RISC处理器采用此架构**。

#### 三、 示例：`C = A + B` 在四种架构中的实现

假设变量 A、B、C 都在存储器中，且 A 和 B 的值在运算后不被破坏。

| (a) 堆栈 (Stack) | (b) 累加器 (Accumulator) | (c) 寄存器-存储器 (Reg-Mem) | (d) 寄存器-寄存器 (Load-Store) |
| :--------------- | :----------------------- | :-------------------------- | :----------------------------- |
| `Push A`         | `Load A`                 | `Load R1, A`                | `Load R1, A`                   |
| `Push B`         | `Add B`                  | `Add R1, B`                 | `Load R2, B`                   |
| `Add`            | `Store C`                | `Store R1, C`               | `Add R3, R1, R2`               |
| `Pop C`          |                          |                             | `Store R3, C`                  |

#### 四、 核心总结

-   在**堆栈结构**和**累加器结构**中，`Add` 指令的操作数是**隐式的**（由栈顶指针或累加器决定）。
-   而在两种**寄存器结构**中，`Add` 指令的操作数都必须**显式地**指定。
-   `Load-Store` 架构将**计算**和**访存**操作完全分离，是现代处理器设计的主流。



#### 五、 通用寄存器 (GPR) 体系结构

通用寄存器架构是现代计算机的主流，它克服了堆栈和累加器架构的瓶颈。

##### 1. 通用寄存器出现的原因
-   **速度优势**: **寄存器比存储器快得多**。将常用数据放在寄存器中能显著提升性能。
-   **编译器优化**: 编译器使用寄存器比使用其他存储形式（如堆栈）**更方便、效率更高**。
    -   *示例*: 对于表达式 `(A*B) - (C*D) - (E*F)`，在寄存器架构中，编译器可以按**任意顺序**执行三个乘法，灵活性高。而在堆栈架构中，计算顺序是固定的，且可能需要多次加载数据。
-   **减少内存流量，改善代码密度**:
    -   用寄存器存放变量，减少了对慢速主存的访问次数，**加速程序运行**。
    -   寄存器地址比存储器地址的**位数少**得多（如5位 vs 32位），使得指令更短，**改善了代码密度**。

##### 2. 通用寄存器ISA的两个关键特性
通用寄存器ISA在设计运算类指令时，主要有两个维度的考量：

1.  **ALU指令中包含两个还是三个操作数？**
    -   **三操作数格式**: `ADD R1, R2, R3`  (R1 = R2 + R3)
        -   一个结果（目的）操作数，两个源操作数。
    -   **二操作数格式**: `ADD R1, R2`  (R1 = R1 + R2)
        -   一个操作数既是源操作数，也是结果操作数。
2.  **ALU指令中包含多少个存储器操作数？**
    -   ALU指令中支持的存储器操作数数量可以是 **0 到 3 个**不等。

#### 六、 基于寄存器ISA的详细分类

根据上述两个特性，通用寄存器体系结构可以进一步细分为三类：

| 存储器地址个数 | 最多操作数个数 | 系统结构类型                  | 举例                                      |
| :------------- | :------------- | :---------------------------- | :---------------------------------------- |
| **0**          | **3**          | **Load-Store (Reg-Reg)**      | **Alpha, ARM, MIPS, PowerPC, SPARC**      |
| **1**          | **2**          | **Register-Memory (Reg-Mem)** | IBM360/370, **Intel x86**, Motorola 68000 |
| **2 或 3**     | **2 或 3**     | **Memory-Memory (Mem-Mem)**   | **VAX** (同时支持2操作数和3操作数格式)    |

*注：纯粹的 Memory-Memory 架构（所有操作数都在内存）在现实中不存在。*

#### 七、 三种常见通用寄存器计算机的优缺点

| 类型                                                   | 优点                                                         | 缺点                                                         |
| :----------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Reg-Reg (Load-Store)** <br> (0个内存地址, 3个操作数) | - **简单、定长的指令编码**<br>- 简单的代码生成模式<br>- **每条指令运行的时钟周期数相近** (利于流水线) | - 目标代码**指令数比直接访问存储器的结构多**<br>- 指令多和指令密度低使得程序变得很大 |
| **Reg-Mem** <br> (1个内存地址, 2个操作数)              | - 数据**不需要专门的载入指令**就可以直接访问<br>- 指令格式更易于编码，**代码密度高** | - **源操作数在二元操作中被破坏** (R1=R1+Mem)，操作数不等价<br>- 在一条指令中同时对存储器地址和寄存器号进行编码，会**限制寄存器的数量**<br>- 操作数位置不同，使得每条指令执行所需的**时钟周期不同** |
| **Mem-Mem** <br> (2或3个内存地址)                      | - **最紧凑**<br>- 不浪费寄存器来做临时交换空间               | - 指令**长短不相同**，特别是三操作数指令<br>- 每条指令的操作各不相同<br>- **存储器访问带来了存储器瓶颈** |

*注：此外，还有一种在累加器基础上扩展了其他寄存器的**扩展累加器**计算机。*