## **2.1 简介**

本节回顾了第一章中提到的三大应用领域，并从**指令集系统 (ISA)** 的角度分析了它们各自的设计侧重点。

#### 一、 三大应用领域的指令集需求

1.  **桌面/科学计算领域**:
    -   注重**定点和浮点运算性能**。
    -   不注重程序（代码）大小及处理器功耗。

2.  **服务器领域**:
    -   主要应用于数据库、文件服务器、Web应用。
    -   注重**定点和字符串处理**性能。
    -   有浮点指令，但其性能不是关键。

3.  **嵌入式领域**:
    -   注重**成本、功耗和代码大小**。
    -   一些复杂指令（如浮点指令）通常作为**可定制的选项**，以控制成本。

#### 二、 核心结论与本章重点

-   **指令集的相似性**: 尽管这三个领域的侧重点不同，但它们的**指令系统仍然非常相似**，共享一个核心基础。

-   **本章学习重点**: 正因为这种相似性，**MIPS 指令集**成为了一个经典的教学和研究案例，因为它在**桌面、服务器和嵌入式**这三个领域中都有着广泛的应用。本章将以 MIPS 为例展开学习。



## **2.2 指令集系统结构的分类**

#### 一、 分类的根本区别

**指令集系统结构 (ISA)** 最根本的区别在于**处理器内部数据的存储结构不同**。这种存储结构决定了指令如何指定其操作数。

-   **内部存储结构**: 主要分为**堆栈 (Stack)**、**累加器 (Accumulator)** 或**一组通用寄存器 (a set of general-purpose registers)**。
-   **操作数指定方式**:
    -   **隐式指定 (Implicit)**: 指令的操作数位置是约定俗成的，不需要在指令中明确指出。
    -   **显式指定 (Explicit)**: 指令中必须明确指出操作数所在的寄存器或内存地址。

#### 二、 四种主要的 ISA 类型

根据内部存储结构，ISA 主要可以分为以下四种类型：

##### (1) 堆栈体系结构 (Stack Architecture)
-   **工作原理**: 所有ALU操作的操作数都**隐式地**位于**栈顶**。
-   **数据流**:
    1.  两个操作数从栈顶弹出，送入ALU。
    2.  ALU进行运算。
    3.  运算结果被压回栈顶。
-   **内存交互**: 通过 `Push`（压栈）和 `Pop`（弹栈）指令与主存进行数据交换。
-   **特点**: 指令非常紧凑，但难以进行乱序执行等优化。

##### (2) 累加器体系结构 (Accumulator Architecture)
-   **工作原理**: 其中一个操作数**隐式地**是**累加器 (Accumulator)** 这个专用寄存器。
-   **数据流**:
    1.  一个操作数来自累加器，另一个来自主存。
    2.  ALU进行运算。
    3.  运算结果**隐式地**存回累加器。
-   **特点**: 指令简单，但累加器成为性能瓶颈，内存流量较大。

##### (3) 寄存器-存储器体系结构 (Register-Memory Architecture)
-   **工作原理**: 操作数被**显式指定**。ALU操作允许一个操作数在寄存器中，另一个在主存中。
-   **数据流**:
    1.  一个操作数来自寄存器，一个来自主存。
    2.  ALU进行运算。
    3.  运算结果存回寄存器。
-   **特点**: 指令格式更复杂，操作数长度不一，不利于流水线设计。

##### (4) 寄存器-寄存器 (Load-Store) 体系结构 (Register-Register or Load-Store Architecture)
-   **工作原理**: 所有ALU操作的操作数都必须**显式地**位于**通用寄存器**中。
-   **数据流**:
    1.  所有操作数都来自寄存器。
    2.  ALU进行运算。
    3.  运算结果存回寄存器。
-   **内存交互**: 只能通过专门的 `Load` (从内存加载到寄存器) 和 `Store` (从寄存器存储到内存) 指令与主存交互。
-   **特点**: 指令格式规整，执行速度快，易于编译器优化和硬件流水线设计。**现代大多数RISC处理器采用此架构**。

#### 三、 示例：`C = A + B` 在四种架构中的实现

假设变量 A、B、C 都在存储器中，且 A 和 B 的值在运算后不被破坏。

| (a) 堆栈 (Stack) | (b) 累加器 (Accumulator) | (c) 寄存器-存储器 (Reg-Mem) | (d) 寄存器-寄存器 (Load-Store) |
| :--------------- | :----------------------- | :-------------------------- | :----------------------------- |
| `Push A`         | `Load A`                 | `Load R1, A`                | `Load R1, A`                   |
| `Push B`         | `Add B`                  | `Add R1, B`                 | `Load R2, B`                   |
| `Add`            | `Store C`                | `Store R1, C`               | `Add R3, R1, R2`               |
| `Pop C`          |                          |                             | `Store R3, C`                  |

> **堆栈是一个逻辑概念，它的物理实现是一个混合体：主体在慢速的主存中，但最常被访问的栈顶部分被缓存在CPU内部速寄存器中，以实现高性能计算。**



![image-20250922164519259](./assets/image-20250922164519259.png)



-   **TOS 是什么？**: TOS (Top of Stack) 在硬件层面指的是**一组用于缓存栈顶元素的高速CPU寄存器**，并由一个**栈顶指针**来管理。
-   **结果放回哪里？**: ALU 的运算结果会**优先放回这些高速的栈顶寄存器**，而不是立即放回主存。
-   **为什么这么做？**: 这种设计是为了**性能优化**。通过将频繁访问的栈顶数据保留在CPU内部，可以避免与慢速主存进行不必要的交互，从而显著提升连续计算的速度。



##### **通用寄存器体系结构的两种划分**

按照**通用寄存器**访问内存的方式，可以进一步将通用寄存器体系结构划分为两种主要类型：

1.  **寄存器-存储器 (register-memory) 体系结构**:
    -   **特点**: **一般指令都可以访问存储器**。这意味着像 `ADD`, `SUB` 这样的算术逻辑指令，其操作数之一可以直接是内存地址。
    -   *示例*: `ADD R1, memory_address` (将寄存器R1的值与内存地址`memory_address`的值相加，结果存回R1)。

2.  **寄存器-寄存器 (register-register) 或 load-store 体系结构**:
    -   **特点**: **只有`load`和`store`指令才能访问内存**。所有的算术逻辑指令（如`ADD`, `SUB`）的操作数必须全部在寄存器中。
    -   **工作流程**:
        1.  使用 `load` 指令将数据从内存加载到寄存器。
        2.  在寄存器之间进行计算。
        3.  使用 `store` 指令将结果从寄存器写回内存。

##### **其他相关体系结构**

-   **纯粹的 memory-memory 体系结构**:
    -   这是一种理论上的结构，其所有操作数都保存在存储器中。
    -   **现实中不存在**这样的纯粹结构，因为它效率极低。

-   **扩展累加器 (Extended Accumulator) 计算机**:
    -   这是一种混合型结构，它在传统的**累加器**之外，又扩展了一些其他的寄存器，以提高灵活性和性能。





#### 四、 核心总结

-   在**堆栈结构**和**累加器结构**中，`Add` 指令的操作数是**隐式的**（由栈顶指针或累加器决定）。
-   而在两种**寄存器结构**中，`Add` 指令的操作数都必须**显式地**指定。
-   `Load-Store` 架构将**计算**和**访存**操作完全分离，是现代处理器设计的主流。



#### 五、 通用寄存器 (GPR) 体系结构

通用寄存器架构是现代计算机的主流，它克服了堆栈和累加器架构的瓶颈。

##### 1. 通用寄存器出现的原因
-   **速度优势**: **寄存器比存储器快得多**。将常用数据放在寄存器中能显著提升性能。
-   **编译器优化**: 编译器使用寄存器比使用其他存储形式（如堆栈）**更方便、效率更高**。
    -   *示例*: 对于表达式 `(A*B) - (C*D) - (E*F)`，在寄存器架构中，编译器可以按**任意顺序**执行三个乘法，灵活性高。而在堆栈架构中，计算顺序是固定的，且可能需要多次加载数据。
-   **减少内存流量，改善代码密度**:
    -   用寄存器存放变量，减少了对慢速主存的访问次数，**加速程序运行**。
    -   寄存器地址比存储器地址的**位数少**得多（如5位 vs 32位），使得指令更短，**改善了代码密度**。

##### 2. 通用寄存器ISA的两个关键特性
通用寄存器ISA在设计运算类指令时，主要有两个维度的考量：

1.  **ALU指令中包含两个还是三个操作数？**
    -   **三操作数格式**: `ADD R1, R2, R3`  (R1 = R2 + R3)
        -   一个结果（目的）操作数，两个源操作数。
    -   **二操作数格式**: `ADD R1, R2`  (R1 = R1 + R2)
        -   一个操作数既是源操作数，也是结果操作数。
2.  **ALU指令中包含多少个存储器操作数？**
    -   ALU指令中支持的存储器操作数数量可以是 **0 到 3 个**不等。

#### 六、 基于寄存器ISA的详细分类

根据上述两个特性，通用寄存器体系结构可以进一步细分为三类：

| 存储器地址个数 | 最多操作数个数 | 系统结构类型                  | 举例                                      |
| :------------- | :------------- | :---------------------------- | :---------------------------------------- |
| **0**          | **3**          | **Load-Store (Reg-Reg)**      | **Alpha, ARM, MIPS, PowerPC, SPARC**      |
| **1**          | **2**          | **Register-Memory (Reg-Mem)** | IBM360/370, **Intel x86**, Motorola 68000 |
| **2 或 3**     | **2 或 3**     | **Memory-Memory (Mem-Mem)**   | **VAX** (同时支持2操作数和3操作数格式)    |

*注：纯粹的 Memory-Memory 架构（所有操作数都在内存）在现实中不存在。*

#### 七、 三种常见通用寄存器计算机的优缺点

| 类型                                                   | 优点                                                         | 缺点                                                         |
| :----------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **Reg-Reg (Load-Store)** <br> (0个内存地址, 3个操作数) | - **简单、定长的指令编码**<br>- 简单的代码生成模式<br>- **每条指令运行的时钟周期数相近** (利于流水线) | - 目标代码**指令数比直接访问存储器的结构多**<br>- 指令多和指令密度低使得程序变得很大 |
| **Reg-Mem** <br> (1个内存地址, 2个操作数)              | - 数据**不需要专门的载入指令**就可以直接访问<br>- 指令格式更易于编码，**代码密度高** | - **源操作数在二元操作中被破坏** (R1=R1+Mem)，操作数不等价<br>- 在一条指令中同时对存储器地址和寄存器号进行编码，会**限制寄存器的数量**<br>- 操作数位置不同，使得每条指令执行所需的**时钟周期不同** |
| **Mem-Mem** <br> (2或3个内存地址)                      | - **最紧凑**<br>- 不浪费寄存器来做临时交换空间               | - 指令**长短不相同**，特别是三操作数指令<br>- 每条指令的操作各不相同<br>- **存储器访问带来了存储器瓶颈** |

*注：此外，还有一种在累加器基础上扩展了其他寄存器的**扩展累加器**计算机。*



## **2.3 存储器寻址**

本节讨论了计算机如何访问内存中的数据，包括数据的基本单位、存储顺序、对齐方式以及定位操作数的各种方法。

### 一、 基本寻址单位与数据类型

-   **字节寻址 (Byte Addressing)**: 现代计算机的内存都被组织成以**字节 (Byte, 8位)** 为基本单位的线性地址空间。地址 `0` 对应第一个字节，地址 `1` 对应第二个字节，以此类推。
-   **支持的数据类型**: 除了基本的字节寻址，指令系统还提供了对更大单位数据的直接寻址支持：
    -   **半字 (Half word)**: 16位
    -   **字 (Word)**: 32位
    -   **双字 (Double word)**: 64位
-   **寻址方式**: 访问一个“字”时，地址会以4为步长递增（0, 4, 8, ...），因为一个字包含4个字节。

### 二、 字节序：大端模式 (Big-Endian) 与小端模式 (Little-Endian)

当一个多字节数据（如一个字）存放在内存中时，其内部字节的排列顺序存在两种模式。

-   **小端模式 (Little-Endian)**: **低地址存放低字节 (L**ow address, **L**ow byte)。
    -   将一个字的最低有效字节 (Least Significant Byte, LSB) 存放在起始的最低地址处。
    -   *例如*: `0xABCD` 存放在地址 `1000`，则内存中 `1000` 存 `CD`，`1001` 存 `AB`。

-   **大端模式 (Big-Endian)**: **低地址存放高字节 (L**ow address, **H**igh byte)。
    -   将一个字的最高有效字节 (Most Significant Byte, MSB) 存放在起始的最低地址处。
    -   *例如*: `0xABCD` 存放在地址 `1000`，则内存中 `1000` 存 `AB`，`1001` 存 `CD`。

### 三、 内存对齐 (Memory Alignment)

-   **定义**: 如果一个 `s` 字节数据的存放地址 `A` 能够满足 `A mod s = 0`，则称这次访问是**对齐的 (Aligned)**。
    -   `2字节` (半字) 数据，其地址应为 `2` 的倍数 (地址二进制末位为0)。
    -   `4字节` (字) 数据，其地址应为 `4` 的倍数 (地址二进制末两位为00)。
    -   `8字节` (双字) 数据，其地址应为 `8` 的倍数 (地址二进制末三位为000)。

-   **为什么需要对齐**:
    1.  **简化硬件**: 许多系统硬件被设计为一次只能从对齐的地址边界读取一个字或双字。对齐访问可以**简化硬件实现的复杂性**。
    2.  **提升性能**: **一次不对齐的存储器访问，可能会导致硬件需要进行多次对齐的存储器访问**。例如，要从地址 `1` 读取一个字 (4字节)，硬件可能需要先读取地址 `0` 处的字，再读取地址 `4` 处的字，然后通过移位和拼接操作才能得到想要的数据。
    -   **结论**: 即使在没有强制对齐限制的计算机里，**对齐访问的程序也会运行得比较快**。

-   **对齐的代价**:
    -   **优点**: 提升了访存性能。
    -   **缺点**: 为了让每个变量都对齐，编译器可能会在变量之间插入一些**填充字节 (Padding)**，从而**浪费存储空间**。
    -   **权衡**: **目前来看，浪费一点存储空间来换取性能提升是完全值得的。**

### 四、 寻址方式 (Addressing Modes)

-   **定义**: 指令中如何指定所要访问操作数的地址。寻址方式要指定**常量**、**寄存器**和**存储器**操作数的位置。

-    *** 立即数通常也被认为是一种存储器寻址方式（尽管它们要访问的数值在指令流里）。**

     ***** **寄存器不属于存储器寻址。**

     ***** **把依赖于程序计数器的PC相对寻址（后面详细讨论）也分离出来。**

-   **常见寻址方式汇总**:

| 寻址方式           | 指令举例              | 含义 (语义)                                                  | 何时使用                             |
| :----------------- | :-------------------- | :----------------------------------------------------------- | :----------------------------------- |
| **寄存器寻址**     | `Add R4, R3`          | `Regs[R4] ← Regs[R4] + Regs[R3]`                             | 操作数在寄存器中                     |
| **立即数寻址**     | `Add R4, #3`          | `Regs[R4] ← Regs[R4] + 3`                                    | 数值是常量                           |
| **位移量寻址**     | `Add R4, 100(R1)`     | `Regs[R4] ← Regs[R4] + Mem[100 + Regs[R1]]`                  | 存取局部变量 (模拟栈指针+偏移)       |
| **寄存器间接寻址** | `Add R4, (R1)`        | `Regs[R4] ← Regs[R4] + Mem[Regs[R1]]`                        | 使用指针或计算出的地址进行寻址       |
| **间接寻址**       | `Add R3, [R1+R2]`     | `Regs[R3] ← Regs[R3] + Mem[Regs[R1] + Regs[R2]]`             | 有用在数组寻址中                     |
| **索引寻址**       | `Add R1, (1001)`      | `Regs[R1] ← Regs[R1] + Mem[1001]`                            | 存取静态数据                         |
| **存储器间接寻址** | `Add R1, @(R3)`       | `Regs[R1] ← Regs[R1] + Mem[Mem[Regs[R3]]]`                   | 如果R3是指针p的地址, 那么就得到*p    |
| **自动递增寻址**   | `Add R1, (R2)+`       | `Regs[R1] ← Regs[R1] + Mem[Regs[R2]]; Regs[R2] ← Regs[R2] + d` | 在循环中递增变量，R2是数组的起始地址 |
| **自动递减寻址**   | `Add R1, -(R2)`       | `Regs[R2] ← Regs[R2] - d; Regs[R1] ← Regs[R1] + Mem[Regs[R2]]` | 类似堆栈的push/pop功能               |
| **比例寻址**       | `Add R1, 100(R2)[R3]` | `Regs[R1] ← Regs[R1] + Mem[100 + Regs[R2] + Regs[R3]*d]`     | 用来进行数组寻址                     |

#### **寻址方式的使用频率分析**

![image-20250922172134577](./assets/image-20250922172134577.png)

##### 一、 测试背景与目的

-   **测试平台**: 选用 **VAX 系统结构**的计算机进行测试。
-   **选择VAX的原因**:
    1.  **寻址方式丰富**: VAX 是一个典型的 CISC 架构，提供了非常全面和复杂的寻址方式，适合进行广泛的统计。
    2.  **限制很少**: VAX 对存储器寻址的限制很少，允许研究人员观察程序在“最自由”的情况下会倾向于使用哪些寻址方式。
-   **测试程序**: 选取了三个有代表性的程序进行测试：`gcc` (编译器)、`spice` (电路模拟)、`TeX` (排版系统)。
-   **统计范围**: 统计了程序中各种**存储器寻址方式**的使用频率（不包括纯粹的寄存器寻址）。

##### 二、 核心统计结果与洞察

统计图表直观地揭示了，尽管存在多种复杂的寻址方式，但程序实际高频使用的寻址方式非常集中。

-   **最常用的寻址方式**:
    1.  **位移量寻址 (Displacement)**: 在所有三个程序中都占据了极高的比例 (32% ~ 55%)。
    2.  **立即数寻址 (Immediate)**: 同样是使用频率最高的寻址方式之一 (17% ~ 43%)。

-   **次要的寻址方式**:
    -   **寄存器间接寻址 (Register Deferred/Indirect)**: 具有一定的使用率，尤其在 `TeX` 中较为常用 (24%)。
    -   **比例寻址 (Scaled)**: 在科学计算程序 `spice` 中使用较多 (16%)，但在其他程序中几乎不用或很少使用。

-   **罕用的寻址方式**:
    -   **存储器间接寻址 (Memory Indirect)** 等更复杂的寻址方式，其使用频率非常低 (通常在 1% 左右)。



#### **位移量寻址方式 **

位移量寻址是现代计算机中使用最频繁的存储器寻址方式之一。其核心设计问题在于如何选择一个合适的**位移量 (Displacement)** 长度。

##### 具体设计

**一、 核心公式**

位移量寻址的本质是**通过一个已知的“基准点”加上一个固定的“偏移”来定位数据**。其计算有效地址 (Effective Address) 的公式为：
`有效地址 = 基址寄存器 (Base Register) 的内容 + 位移量 (Displacement / Offset)`

**二、 关键组成部分**

1.  **基址寄存器 (Base Register)**:
    -   这是一个通用寄存器，其内容是一个内存地址。
    -   这个地址扮演着一个数据区域的“基准点”或“起始点”的角色。常见的基准点有：
        -   **栈帧指针 (FP/SP)**: 指向当前函数局部变量区域的起点。
        -   **全局数据指针 (GP)**: 指向全局变量区域的起点。
        -   **数据结构指针**: 指向一个结构体或数组的起始地址。

2.  **位移量 / 偏移 (Displacement / Offset)**:
    -   **定义**: 这是一个直接编码在指令中的**常量值**。
    -   **作用**: 它表示目标数据距离基准点有多远。
    -   在这个语境下，**“位移量”** 和 **“偏移”** 是可以互换使用的同义词。

**三、 位移量是如何确定的？**

位移量并非在程序运行时动态计算，而是在**编译阶段 (Compile Time)** 由**编译器**静态计算并确定的。

编译器在内存中组织程序的数据布局时，就已经精确规划好了每个变量相对于其基准点的相对位置（即偏移）。

-   **示例1：访问结构体成员**
    -   如果一个结构体的起始地址存放在基址寄存器 `R1` 中，那么访问该结构体的某个成员时，所用的**位移量**就是该成员在结构体定义中的**字节偏移**。例如，访问偏移为8字节的成员，位移量就是`8`。

-   **示例2：访问局部变量**
    -   函数的局部变量存放在栈帧中，其位置相对于**帧指针(FP)**是固定的。编译器会计算出每个局部变量相对于 `FP` 的**负偏移**，并将其作为**位移量**编码到指令中。



##### 一、 设计考量

-   **核心问题**: 位移量的**范围**应该是多大？即在指令中应该分配多少位 (bits) 来表示这个位移量。
-   **设计权衡**:
    -   **更长的位移量**:
        -   **优点**: 可以一次性访问距离基址寄存器更远的数据，无需额外指令。
        -   **缺点**: 会占用指令中更多的位数，导致**指令长度变长**，或者挤占其他字段（如操作码、寄存器号）的空间。
    -   **更短的位移量**:
        -   **优点**: 指令编码更紧凑，节省指令空间。
        -   **缺点**: 当需要访问较远的数据时，可能需要多条指令来构造地址，降低了程序效率。

-   **结论**: 选择位移量的长度会**直接影响指令的长度**和架构的整体效率，是一个关键的设计决策。

##### 二、 Alpha 架构上的测试与数据分析

为了科学地做出决策，研究人员在 **Alpha 架构**（其指令提供 **16位** 位移量）上运行了 `SPEC CPU2000` 的整数 (CINT2000) 和浮点 (CFP2000) 测试程序集，统计了访存指令中实际使用的位移量值的分布情况。

-   **图表分析**:
    -   **横轴**: 位移量所需的位数（例如，`4` 表示位移量值在 `±2³` 到 `±2⁴-1` 之间）。
    -   **纵轴**: 该范围的位移量在所有位移量寻址中被使用的频率。
-   **核心观察**:
    1.  **绝大多数位移量都很小**: 统计图显示，绝大部分（通常超过50%）的位移量值都非常小，只需要很少的位数（如0-7位）就能表示。这主要对应于对**栈帧 (stack frame)** 中局部变量的访问。
    2.  **存在对较大位移量的需求**: 图中也清晰地显示，在需要 **12 到 15 位**才能表示的较大位移量范围内，同样存在一个显著的使用高峰。这通常对应于对**全局数据区 (global data area)** 变量的访问。
    3.  **分布范围很广**: 总体来看，位移量值的分布范围很广，从非常小到接近16位所能表示的极限都有涉及。这是由于程序的存储布局、存取方式以及编译器选择的不同策略共同导致的。

##### 三、 最终结论

-   **关键结论**: 从统计数据来看，为了能够高效地覆盖绝大多数常用场景（特别是对全局数据的访问），**提供 12 到 16 位的位移量是必要的**。
-   **设计采纳**: 基于类似的研究，许多现代RISC架构都做出了相似的设计选择。例如，**MIPS 架构就采用了 16 位的位移量**，这被证明是一个在指令长度和寻址范围之间取得了良好平衡的有效设计。



#### **立即数寻址方式**

立即数寻址是将常量值直接编码在指令中的一种高效寻址方式。其核心设计问题与位移量寻址类似，即如何选择一个合适的立即数长度。

##### 一、 设计考量与应用场景

-   **核心问题**: **立即数的范围**应该是多大？这同样会直接影响**指令的长度**和架构效率。
-   **应用场景**: 立即数寻址常用于：
    -   **算术运算指令**: 如 `ADD R1, R1, #5` (将 R1 的值加 5)。
    -   **载入常数到寄存器**: 如 `LI R2, #1024` (将 1024 载入 R2)。
    -   **比较指令**: 用于条件转移指令中的判断条件，如 `BEQ R1, #0, Label` (如果 R1 等于 0，则跳转)。
-   **关键设计决策**: 指令集是应该**支持所有操作**都使用立即数，还是**只支持一部分常用操作**？这个决策对指令系统的设计很重要。

##### 二、 Alpha 架构上的测试与数据分析

为了确定需要多大的立即数，研究人员在 **Alpha 架构**（最大支持 **16位** 立即数）上运行了 `SPEC CPU2000` 测试集，统计了实际使用的立即数值的分布情况。

-   **图表分析**:
    -   **X轴**: 表示一个立即数值所需要的位数（例如，`4` 表示该立即数的值在 `2³` 到 `2⁴-1` 之间，`0` 表示值为0）。
    -   **Y轴**: 该范围的立即数在所有立即数寻址中被使用的频率。
-   **核心观察**:
    1.  **小立即数最常用**: 无论是定点还是浮点程序，**小数值的立即数**（如0、1等，仅需少量位数表示）使用得**最最频繁**。
    2.  **存在对大立即数的需求**: 尽管小立即数占主导，但程序中有时也会使用较大的立即数，特别是在**寻址计算**中。
    3.  **定点与浮点的差异**:
        -   **定点程序 (CINT)**: 立即数使用频率的分布相对平缓，对各种大小的立即数都有需求。
        -   **浮点程序 (CFP)**: 立即数的使用**高度集中**在非常小的数值上（如图中 `4` 对应的峰值，高达 `42%`）。

##### 三、 综合分析与最终结论

-   **正负数分布**: 大多数立即数是正值。在 `CINT2000` 中约有 `20%` 的立即数是负数，在 `CFP2000` 中约为 `30%`。
-   **与VAX的对比**: 在一台支持32位立即数的VAX计算机上进行相同测试，结果显示有 **20%~25%** 的立即数**大于16位**。
    -   **推论**:
        -   支持**16位及以下**的立即数可以覆盖约 **80%** 的场景。
        -   支持**8位及以下**的立即数可以覆盖约 **50%** 的场景。
-   **最终结论**: 为了在指令长度和功能覆盖率之间取得良好平衡，**提供 8~16 位的立即数是必要的**。
-   **设计采纳**: 基于此结论，现代RISC架构如 **MIPS** 和 **ALPHA** 都采用了 **16位** 的立即数设计。

##### 四、 立即数使用频率
-   大约有 **1/4** 的数据传输和定点ALU操作包含一个立即数操作数。
-   在 `SPEC2000` 测试中，定点程序中有约 **1/5** (20%) 的指令用到了立即数，在浮点程序中这个比例约为 **1/6** (~17%)。



### **寻址方式小结**

-   **一般ISA支持的基本寻址方式**:
    -   根据对程序行为的统计分析，现代指令集（ISA）通常会优先支持以下几种最常用、最高效的寻址方式：
        1.  **立即数寻址 (Immediate Addressing)**
        2.  **位移量寻址 (Displacement Addressing)**
        3.  **寄存器间址 (Register Indirect Addressing)**

-   **立即数与位移量的推荐长度**:
    -   为了在指令编码的紧凑性和寻址能力的覆盖范围之间取得良好平衡，推荐的设计值为：
        -   **立即数**: 支持 **8 ~ 16 位**。
        -   **位移量**: 支持 **12 ~ 16 位**。
    -   这个范围能够覆盖绝大多数程序（超过80%）的访存和常量使用需求。



## **2.4 操作数的大小与类型**

本节讨论了指令系统如何定义和区分不同大小和类型的操作数，以及在实际程序中各种数据类型的访问频率。

#### 一、 操作数类型的指定方式

计算机硬件需要知道如何解释内存中的二进制位串（例如，一个32位的数据究竟是整数还是浮点数）。指令系统通过以下两种方式来指定操作数的类型：

1.  **通过操作码 (Opcode) 的编码来指定**:
    -   **描述**: 这是**最常用**的方法。指令的操作码本身就隐含了操作数的数据类型。
    -   **示例**: `ADD` 指令可能用于整数加法，而 `ADD.S` (或 `FADD`) 指令则专门用于单精度浮点数加法。硬件通过解码 `ADD` 或 `ADD.S` 就能知道该如何处理后续的操作数。

2.  **通过操作数中用硬件解释的字段来表示**:
    -   **描述**: 数据本身带有一个“标签 (Tag)”字段，用来表明其数据类型。硬件在处理数据前会先检查这个标签。
    -   **应用**: 这种方法不常见，主要用于一些特殊的、支持动态类型的体系结构中。

#### 二、 常见的数据类型、大小与表示

下表列出了现代计算机中常见的操作数类型及其属性：

| 数据类型             | 位数 | 数值范围                      | C 语言中的对应       |
| :------------------- | :--- | :---------------------------- | :------------------- |
| **字节 (Byte)**      | 8    | `-128` ~ `+127`               | `signed char`        |
| **无符号字节**       | 8    | `0` ~ `255`                   | `unsigned char`      |
| **半字 (Half word)** | 16   | `-32768` ~ `+32767`           | `short int`          |
| **无符号半字**       | 16   | `0` ~ `65535`                 | `unsigned short int` |
| **字 (Word)**        | 32   | `-2147483648` ~ `+2147483647` | `int`                |
| **无符号字**         | 32   | `0` ~ `4294967295`            | `unsigned int`       |
| **单精度浮点数**     | 32   | -                             | `float`              |
| **双精度浮点数**     | 64   | -                             | `double`             |

-   **编码格式**:
    -   **定点数** (整数) 通常用**二进制补码**表示。
    -   **字符**通常是 **ASCII** 编码格式。

#### 三、 实际程序中数据访问的大小分布

通过在 **64位处理器**上运行基准测试程序，可以统计出不同大小数据的访问频率，从而指导体系结构的设计。

-   **统计图分析**:
    -   **浮点程序 (平均值)**:
        -   **双字 (64位)** 访问占绝对主导，高达 **70%**。
        -   **字 (32位)** 访问占 `29%`。
        -   半字和字节访问非常少。
    -   **定点程序 (平均值)**:
        -   **双字 (64位)** 访问同样是主流，占 **59%**。
        -   **字 (32位)** 访问占 `26%`。
        -   **字节 (8位)** 访问占 `10%`。
        -   半字访问最少。

-   **数据解读与分析**:
    1.  **64位系统中的双字访问**:
        -   在**浮点程序**中，双字访问主要对应于**双精度 (double) 浮点数**的运算。
        -   在**定点程序**中，双字访问主要对应于**存储器地址**的计算和访问 (因为在64位系统中，指针是64位的)。
    2.  **在32位系统中的变化**:
        -   如果在 **32位地址**的计算机上进行相同测试，情况会发生显著变化。
        -   由于指针变为32位，定点程序中几乎所有的**双字访问都将转换成单字访问**。
    3.  **对寄存器内部的访问**:
        -   在一些体系结构中（如VAX），允许以字节或半字为单位访问一个寄存器的部分内容。
        -   然而，这种用法**非常罕见**。统计表明，在VAX上这类访问不超过所有寄存器访问的 `12%`，大约占所有操作数访问的 `6%`。

#### 四、 核心结论

-   在现代64位系统中，无论是定点还是浮点程序，**对64位（双字）和32位（字）数据的访问占据了绝对主导地位**。
-   体系结构的设计应该**优先优化**对这两种最常用数据类型的处理效率。
-   对字节和半字的访问虽然存在，但频率较低，可以作为次要的优化目标。



## **2.5 指令系统的操作**

本节对指令系统中包含的操作类型进行了分类，并分析了各类指令在实际程序中的使用频率。

#### 一、 指令操作类型的分类

指令系统提供的操作可以根据其功能大致分为以下几类：

| 操作类型           | 举例                                                 |
| :----------------- | :--------------------------------------------------- |
| **算术和逻辑运算** | **定点算术和逻辑操作**: 加、减、与、或、乘、除       |
| **数据传输**       | **Load-store指令** (在REG-MEM结构计算机上是传送指令) |
| **控制**           | 条件转移、跳转、过程调用和返回、陷阱 (Trap)          |
| **系统**           | 操作系统调用、虚拟存储器管理指令                     |
| **浮点**           | 浮点操作: 加、减、乘、除、比较                       |
| **十进制**         | 十进制加、十进制乘、十进制到字符的转换               |
| **字符串**         | 字符串传送、字符串比较、字符串匹配                   |
| **图像**           | 像素、顶点操作、压缩/解压缩操作                      |

#### 二、 指令使用的普遍规律

-   **共同规律**: 指令系统有一条共同的规律——**使用最多的是一些简单指令**。
-   **指令集的构成**:
    -   **核心指令**: **前三类指令**（算术和逻辑运算、数据传输、控制）是任何通用计算机都必须提供的基础。
    -   **扩展指令**: 对于**后四类指令**（浮点、十进制、字符串、图像），不同的指令集对其支持程度差异很大。一个指令集可能完全不支持它们（数量为0），也可能包含大量用于加速这些特定任务的特殊指令。

#### 三、 常用指令的频率统计 (以 80x86 为例)

通过统计 80x86 架构上运行的定点程序，可以清晰地看到哪些指令是“常用事件”。

-   **Top 10 最常用指令及其占比**:

| 排名     | 80x86指令                         | 定点平均值 (占百分比) |
| :------- | :-------------------------------- | :-------------------- |
| 1        | **载入 (Load)**                   | 22%                   |
| 2        | **条件转移 (Conditional Branch)** | 20%                   |
| 3        | **比较 (Compare)**                | 16%                   |
| 4        | **存储 (Store)**                  | 12%                   |
| 5        | 加 (Add)                          | 8%                    |
| 6        | 与 (And)                          | 6%                    |
| 7        | 减 (Sub)                          | 5%                    |
| 8        | Reg-Reg传输 (Move)                | 4%                    |
| 9        | 调用 (Call)                       | 1%                    |
| 10       | 返回 (Return)                     | 1%                    |
| **总计** |                                   | **96%**               |

-   **核心结论与设计启示**:
    -   仅仅 **10 类指令**就占据了定点程序中所有执行指令的 **96%**。
    -   这再次印证了“**注重常用事件 (Focus on the Common Case)**”的设计原则。
    -   对于体系结构的设计者来说，这意味着必须**优先优化这 10 类最常用指令的执行效率**，让它们执行起来尽量快，这样才能获得最大的整体性能提升。
    -   

## **2.6 控制流指令**

控制流指令用于改变程序正常的顺序执行流程，是实现循环、分支、函数调用等高级语言结构的基础。

#### 一、 控制流指令的分类与频率

1.  **主要分类**:
    -   **条件转移 (Conditional Branch)**: 根据某个条件决定是否跳转，如 `if-else`。
    -   **跳转 (Jump/Unconditional Branch)**: 无条件地改变执行流程。
    -   **过程调用 (Procedure Call)**: 跳转到一个函数/过程。
    -   **过程返回 (Procedure Return)**: 从函数/过程返回。

2.  **相对频率 (Alpha 上测试)**:
    -   **条件转移**是使用最频繁的控制流指令，在定点和浮点程序中均占 **~75%-82%**。
    -   **调用/返回**和**跳转**的使用频率远低于条件转移。

#### 二、 目标地址的指定方式

控制流指令一般都要指明转移的目标地址，主要有两种指定方式：

##### 1. PC相对寻址 (PC-relative Addressing)
-   **定义**: 使用基于**程序计数器 (PC)** 的位移量来指定目标地址。
    -   **MIPS 示例**: `分支的目标地址 = 16位带符号位移量左移2位 + (PC+4)`
        -   左移2位是因为MIPS指令是4字节对齐的，位移量以“字”为单位。
        -   `PC+4` 是因为在取当前指令时，PC已经指向了下一条指令。
-   **优点**:
    -   **代码紧凑**: 目标地址通常与当前指令**离得不远**，使用相对偏移比使用绝对地址更节省指令空间。
    -   **位置无关代码 (Position-Independent Code)**: 使用相对寻址的程序可以被加载到内存的任何位置而无需修改，这对于在执行时才链接的**动态链接库 (DLL)** 非常重要，可以减少链接器的工作量。
-   **位移量大小**: 在Alpha上测试表明，绝大多数转移的距离都很短（在`2^7`条指令内），因此 **至少8位** 的定点相对寻址位移量是必要的。

##### 2. 寄存器间接跳转 (Register Indirect Jump)
-   **使用场景**: 当**编译时不知道目标地址**时，需要使用这种方式。
-   **定义**: 指令中给出一个包含了目标地址的寄存器名称。
-   **典型应用**:
    -   **过程返回**: `JR R31` (MIPS中，`R31`默认保存返回地址)。
    -   **分支选择语句**: C语言的 `case` 或 `switch` 语句，通过跳转表实现。
    -   **虚函数/方法**: 面向对象语言中，通过虚函数表动态确定调用地址。
    -   **高阶函数或函数指针**: 函数地址作为变量传递。
    -   **动态共享库**: 在程序运行时才确定函数地址。
-   **工作流程**: 在执行跳转之前，先把目标地址从存储器载入到寄存器中。

#### 三、 条件转移的实现方案

如何测试并执行条件转移，主要有三种设计方案：

| 名称                                | 举例                       | 如何测试条件                                                 | 优点                                       | 缺点                                                         |
| :---------------------------------- | :------------------------- | :----------------------------------------------------------- | :----------------------------------------- | :----------------------------------------------------------- |
| **条件码 (CC)** <br> Condition Code | 80x86, ARM, PowerPC, SPARC | 由之前的ALU操作**设定特定状态位** (如零标志、负标志)，转移指令测试这些状态位。 | 有时条件可以“免费”设置 (ALU操作的副作用)。 | CC是附加状态，**增加了指令间的依赖**，改变了指令顺序，对流水线不友好。 |
| **条件寄存器**                      | Alpha, MIPS                | 用**比较指令的结果**测试任意寄存器。                         | 简单。                                     | **占用一个通用寄存器**来保存比较结果 (通常是0或1)。          |
| **比较并转移**                      | PA-RISC, VAX               | 比较是转移指令的**一部分**，通常比较只限于子集内部。         | 一个转移是一条而不是两条指令。             | 对流水线执行来说，**一条指令要做的的事情可能太多了** (读操作数、比较、计算目标地址)。 |

-   **条件类型频率 (Alpha 上测试)**:
    -   最常用的比较类型是 **小于 (35%)** 和 **小于等于 (44%)**。
    -   其次是 **等于 (18%)** 和 **不等于 (5%)**。
    -   大于和大于等于的比较非常罕见，通常可以通过交换操作数转换成小于/小于等于。

#### 四、 过程调用的可选方案：寄存器保存约定

在过程（函数）调用中，为了防止被调用者破坏调用者还需要使用的寄存器，必须有一套寄存器保存的约定。

-   **调用者保存 (Caller-Saved)**:
    -   **约定**: **调用者 (Caller)** 在调用其他过程前，必须自己负责保存那些在调用返回后还需使用的寄存器。被调用者 (Callee) 可以随意使用这些寄存器。
-   **被调用者保存 (Callee-Saved)**:
    -   **约定**: **被调用者 (Callee)** 在执行自己代码前，必须先保存它将要使用的寄存器，并在返回前恢复它们。调用者则无需担心这些寄存器被修改。
-   **实际应用**:
    -   大多数实际使用的编译器会**结合使用这两种方法**，将寄存器划分为调用者保存和被调用者保存两类，以达到最优效率。
    -   当两个不同的过程都需要访问相同的全局变量时，通常必须使用**调用者保存**方法来确保数据一致性。

